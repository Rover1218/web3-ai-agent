"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_lib_groq_ts";
exports.ids = ["_rsc_lib_groq_ts"];
exports.modules = {

/***/ "(rsc)/./lib/groq.ts":
/*!*********************!*\
  !*** ./lib/groq.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeCryptoData: () => (/* binding */ analyzeCryptoData),\n/* harmony export */   generateInsights: () => (/* binding */ generateInsights)\n/* harmony export */ });\n/* harmony import */ var groq_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! groq-sdk */ \"(rsc)/./node_modules/groq-sdk/index.mjs\");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"(rsc)/./lib/api.ts\");\n\n\n// Helper functions for data extraction\nfunction extractTokens(query) {\n    const tokens = [\n        \"BTC\",\n        \"ETH\",\n        \"USDT\",\n        \"USDC\",\n        \"BNB\",\n        \"SOL\",\n        \"ADA\",\n        \"DOT\",\n        \"AVAX\",\n        \"MATIC\"\n    ];\n    return tokens.filter((token)=>query.toUpperCase().includes(token));\n}\nfunction extractProjects(query) {\n    const projects = [\n        \"Uniswap\",\n        \"Aave\",\n        \"Compound\",\n        \"Maker\",\n        \"Curve\",\n        \"Sushi\",\n        \"PancakeSwap\"\n    ];\n    return projects.filter((project)=>query.toLowerCase().includes(project.toLowerCase()));\n}\nfunction extractTimeFrame(query) {\n    if (query.toLowerCase().includes(\"day\") || query.toLowerCase().includes(\"24h\")) return \"day\";\n    if (query.toLowerCase().includes(\"week\") || query.toLowerCase().includes(\"7d\")) return \"week\";\n    if (query.toLowerCase().includes(\"month\") || query.toLowerCase().includes(\"30d\")) return \"month\";\n    return \"week\";\n}\n// Groq API configuration with fallback models\nconst GROQ_MODELS = [\n    \"llama-3.1-8b-instant\",\n    \"llama-3.1-70b-versatile\",\n    \"mixtral-8x7b-32768\",\n    \"gemma2-9b-it\" // Fallback\n];\nlet currentModelIndex = 0;\nconst getGroqModel = ()=>{\n    return GROQ_MODELS[currentModelIndex] || GROQ_MODELS[0];\n};\nconst nextModel = ()=>{\n    currentModelIndex = (currentModelIndex + 1) % GROQ_MODELS.length;\n    return getGroqModel();\n};\n// Initialize without explicitly setting the API key, it will use GROQ_API_KEY env var automatically\nconst groq = new groq_sdk__WEBPACK_IMPORTED_MODULE_1__.Groq();\n// Available model fallbacks in order of preference\nconst MODEL_FALLBACKS = [\n    \"llama-3.3-70b-versatile\",\n    \"llama-3.2-70b-versatile\",\n    \"gemma-7b-it\",\n    \"mistral-7b-instruct\",\n    \"mixtral-8x7b-32768\" // Fallback 4\n];\n// Function to select the appropriate model based on retry count\nfunction getCurrentModel(retryCount = 0) {\n    // If retryCount is beyond our available models, use the last one\n    const index = Math.min(retryCount, MODEL_FALLBACKS.length - 1);\n    const model = MODEL_FALLBACKS[index];\n    console.log(`Using model: ${model} (retry attempt: ${retryCount})`);\n    return model;\n}\nfunction detectIntents(query) {\n    const q = query.toLowerCase();\n    // Check if query is crypto-related\n    const isCryptoRelated = /crypto|bitcoin|ethereum|defi|blockchain|token|coin|market|price|tvl|protocol|trading|wallet|exchange|nft|web3|metaverse|dao|yield|staking|liquidity|swap|amm|dex|cex|altcoin|meme|stablecoin|governance|validator|mining|hash|gas|fee|slippage|impermanent|loss|apy|apr|volume|marketcap|cap|rank|chart|technical|fundamental|analysis|trend|bull|bear|pump|dump|hodl|fomo|fud|shill|moon|lambo|rekt|ser|anon|gm|wagmi|ngmi|diamond|hands|paper|hands|dca|btc|eth|usdt|usdc|dai|link|uni|aave|comp|mkr|sushi|curve|balancer|yearn|harvest|pickle|cream|alpha|beta|gamma|delta|theta|vega|rho|greeks|options|futures|perpetual|leverage|margin|short|long|hedge|arbitrage|frontrun|sandwich|mev|flash|loan|collateral|debt|ceiling|floor|resistance|support|fibonacci|rsi|macd|bollinger|moving|average|ema|sma|ema|volume|profile|order|book|bid|ask|spread|depth|liquidity|pool|pair|route|slippage|impact|price|impact|curve|bonding|curve|amm|automated|market|maker|constant|product|constant|sum|constant|mean|geometric|mean|harmonic|mean|weighted|average|price|vwap|twap|oracle|chainlink|band|nest|pyth|umbrella|api3|dia|tellor|provable|random|number|generator|vrf|verifiable|random|function|commit|reveal|scheme|zero|knowledge|proof|zkp|snark|stark|plonk|groth|bulletproof|range|proof|ring|signature|confidential|transaction|mimblewimble|grin|beam|monero|privacy|coin|mixer|tumbler|coinjoin|wasabi|samourai|joinmarket|atomic|swap|cross|chain|bridge|wormhole|multichain|anyswap|stargate|layer|zero|cosmos|polkadot|avalanche|polygon|arbitrum|optimism|base|zksync|scroll|linea|mantle|op|stack|rollup|zk|rollup|optimistic|rollup|validium|plasma|state|channel|payment|channel|lightning|network|liquid|sidechain|peg|in|peg|out|wrapped|token|wbtc|weth|wmatic|wavax|wbnb|wftm|wone|wmovr|wglmr|wksm|wdot|watom|wosmo|wjun|wscrt|wband|wlink|wuni|waave|wcomp|wmkr|wsushi|wcurve|wbalancer|wyearn|wharvest|wpickle|wcream|walpha|wbeta|wgamma|wdelta|wtheta|wvega|wrho|wgreeks|woptions|wfutures|wperpetual|wleverage|wmargin|wshort|wlong|whedge|warbitrage|wfrontrun|wsandwich|wmev|wflash|wloan|wcollateral|wdebt|wceiling|wfloor|wresistance|wsupport|wfibonacci|wrsi|wmacd|wbollinger|wmoving|waverage|wema|wsma|wema|wvolume|wprofile|worder|wbook|wbid|wask|wspread|wdepth|wliquidity|wpool|wpair|wroute|wslippage|wimpact|wprice|wimpact|wcurve|wbonding|wcurve|wamm|wautomated|wmarket|wmaker|wconstant|wproduct|wconstant|wsum|wconstant|wmean|wgeometric|wmean|wharmonic|wmean|wweighted|waverage|wprice|wvwap|wtwap|woracle|wchainlink|wband|wnest|wpyth|wumbrella|wapi3|wdia|wtellor|wprovable|wrandom|wnumber|wgenerator|wvrf|wverifiable|wrandom|wfunction|wcommit|wreveal|wscheme|wzero|wknowledge|wproof|wzkp|wsnark|wstark|wplonk|wgroth|wbulletproof|wrange|wproof|wring|wsignature|wconfidential|wtransaction|wmimblewimble|wgrin|wbeam|wmonero|wprivacy|wcoin|wmixer|wtumbler|wcoinjoin|wwasabi|wsamourai|wjoinmarket|watomic|wswap|wcross|wchain|wbridge|wwormhole|wmultichain|wanyswap|wstargate|wlayer|wzero|wcosmos|wpolkadot|wavalanche|wpolygon|warbitrum|woptimism|wbase|wzksync|wscroll|wlinea|wmantle|wop|wstack|wrollup|wzk|wrollup|woptimistic|wrollup|wvalidium|wplasma|wstate|wchannel|wpayment|wchannel|wlightning|wnetwork|wliquid|wsidechain|wpeg|win|wpeg|wout|wwrapped|wtoken/.test(q);\n    // If not crypto-related, return all false\n    if (!isCryptoRelated) {\n        return {\n            showDeFi: false,\n            showTable: false,\n            isCryptoQuery: false\n        };\n    }\n    return {\n        showDeFi: /defi|protocol|tvl|project|compare|top|performance|growth/.test(q),\n        showTable: /compare|table|list|top|performance|summary|metrics/.test(q),\n        showEtherscan: /ethereum|eth|contract|transaction|gas|blockchain|address|token|smart contract/.test(q),\n        isCryptoQuery: true\n    };\n}\n// Generate data table from raw data sources that's relevant to the query\nfunction generateDataTableFromRawData(data, query = \"\") {\n    console.log(\"\\uD83D\\uDD04 Generating data table from raw data for query:\", query);\n    console.log(\"\\uD83D\\uDCCA Input data structure:\", {\n        defiProjectsCount: data.defiProjects?.length || 0,\n        cryptoDataCount: data.cryptoData?.length || 0\n    });\n    const tableRows = [];\n    try {\n        // Extract query context if available\n        const queryContext = data.queryContext || {\n            timeFrame: \"week\",\n            topN: 5,\n            useTrending: false\n        };\n        // Create a better mapping between DeFi projects and their tokens\n        const projectTokenMapping = {\n            \"Uniswap\": \"UNI\",\n            \"Aave\": \"AAVE\",\n            \"Compound\": \"COMP\",\n            \"MakerDAO\": \"MKR\",\n            \"Lido\": \"LDO\",\n            \"Curve\": \"CRV\",\n            \"SushiSwap\": \"SUSHI\",\n            \"Yearn Finance\": \"YFI\",\n            \"Synthetix\": \"SNX\",\n            \"PancakeSwap\": \"CAKE\",\n            \"Balancer\": \"BAL\",\n            \"1inch\": \"1INCH\"\n        };\n        // If we have DeFi projects, use them as the primary data source\n        if (data.defiProjects && Array.isArray(data.defiProjects)) {\n            console.log(\"\\uD83C\\uDFDB️ Processing DeFi projects data\");\n            // Sort projects based on query context\n            let sortedProjects = [\n                ...data.defiProjects\n            ];\n            // If query mentions TVL or growth, sort by TVL\n            if (query.toLowerCase().includes(\"tvl\") || query.toLowerCase().includes(\"growth\") || query.toLowerCase().includes(\"surge\")) {\n                if (query.toLowerCase().includes(\"highest\") || query.toLowerCase().includes(\"top\") || query.toLowerCase().includes(\"best\")) {\n                    // Sort by TVL descending\n                    sortedProjects.sort((a, b)=>(b.tvl || 0) - (a.tvl || 0));\n                } else if (query.toLowerCase().includes(\"change\") || query.toLowerCase().includes(\"growth\") || query.toLowerCase().includes(\"surge\")) {\n                    // Sort by TVL change\n                    sortedProjects.sort((a, b)=>(b.tvlChange7d || b.tvlChange24h || 0) - (a.tvlChange7d || a.tvlChange24h || 0));\n                }\n            }\n            // Limit to a reasonable number of rows based on the query\n            const limit = query.toLowerCase().includes(\"top 10\") ? 10 : query.toLowerCase().includes(\"top 5\") ? 5 : Math.min(10, queryContext.topN || 5);\n            sortedProjects.slice(0, limit).forEach((project, index)=>{\n                if (project && project.name) {\n                    // Find corresponding crypto price data using better matching\n                    const tokenSymbol = projectTokenMapping[project.name] || project.symbol;\n                    const cryptoData = data.cryptoData?.find((c)=>c?.symbol?.toLowerCase() === tokenSymbol?.toLowerCase() || c?.symbol?.toLowerCase() === project.symbol?.toLowerCase() || c?.name?.toLowerCase().includes(project.name.toLowerCase()) || project.name.toLowerCase().includes(c?.name?.toLowerCase()));\n                    if (index < 3) {\n                        console.log(`🔍 Project ${project.name}:`, {\n                            tokenSymbol,\n                            foundCrypto: !!cryptoData,\n                            cryptoPrice: cryptoData?.price\n                        });\n                    }\n                    // Create a predictable mapping of DeFi projects to sentiments\n                    const defiProjectSentiments = {\n                        \"Uniswap\": \"Positive\",\n                        \"Aave\": \"Positive\",\n                        \"Compound\": \"Neutral\",\n                        \"MakerDAO\": \"Positive\",\n                        \"Curve\": \"Neutral\",\n                        \"Lido\": \"Positive\",\n                        \"SushiSwap\": \"Neutral\",\n                        \"Yearn Finance\": \"Neutral\",\n                        \"Synthetix\": \"Positive\",\n                        \"PancakeSwap\": \"Positive\",\n                        \"Balancer\": \"Neutral\",\n                        \"1inch\": \"Neutral\"\n                    };\n                    // Extract change values\n                    const priceChange = cryptoData?.priceChange24h || 0;\n                    const tvlChange = project.tvlChange7d || project.tvlChange24h || 0;\n                    // Use the predefined sentiment or calculate based on metrics\n                    let sentiment = defiProjectSentiments[project.name] || \"Neutral\";\n                    // Only use calculations for projects not in our mapping\n                    if (!defiProjectSentiments[project.name]) {\n                        // If both metrics are available, use them both\n                        if (cryptoData && (priceChange !== 0 || tvlChange !== 0)) {\n                            // Weight price changes more heavily than TVL\n                            const combinedChange = cryptoData ? priceChange * 0.7 + tvlChange * 0.3 : tvlChange;\n                            if (combinedChange > 2.5) sentiment = \"Positive\";\n                            else if (combinedChange < -2.5) sentiment = \"Negative\";\n                        }\n                    }\n                    // Calculate news count based on actual news events if available\n                    let newsCount;\n                    // Check if we have news events data\n                    if (data.newsEvents && Array.isArray(data.newsEvents) && data.newsEvents.length > 0) {\n                        // Count news events related to this project\n                        const projectNews = data.newsEvents.filter((news)=>news.title.includes(project.name) || project.symbol && news.title.includes(project.symbol));\n                        newsCount = projectNews.length;\n                        // If no news was found, use a small default value\n                        if (newsCount === 0) {\n                            newsCount = Math.floor(Math.random() * 5) + 1;\n                        }\n                    } else {\n                        // Fallback to generate a realistic news count based on the project popularity\n                        const baseNewsCount = Math.floor(5 + (project.tvl || 0) / 1e9); // More TVL = more news\n                        newsCount = Math.min(30, Math.max(5, baseNewsCount + (Math.abs(tvlChange) > 5 ? 10 : 0 // Big TVL changes generate more news\n                        )));\n                    }\n                    tableRows.push({\n                        project: project.name,\n                        tvl: formatCurrency(project.tvl || 0),\n                        tvlChange: formatPercentage(tvlChange),\n                        price: cryptoData ? formatCurrency(cryptoData.price || 0) : \"N/A\",\n                        priceChange: cryptoData ? formatPercentage(priceChange) : \"N/A\",\n                        sentiment: sentiment,\n                        newsCount: newsCount\n                    });\n                }\n            });\n        }\n        // If no DeFi projects but we have crypto data, use crypto data\n        if (tableRows.length === 0 && data.cryptoData && Array.isArray(data.cryptoData)) {\n            console.log(\"\\uD83D\\uDCB0 Falling back to crypto data\");\n            data.cryptoData.slice(0, 10).forEach((crypto)=>{\n                if (crypto && crypto.name) {\n                    // Determine sentiment based on price change with fixed thresholds\n                    let sentiment = \"Neutral\";\n                    const priceChange = crypto.priceChange24h || 0;\n                    // Use stricter thresholds to make sentiment more stable\n                    if (priceChange > 2.5) sentiment = \"Positive\";\n                    else if (priceChange < -2.5) sentiment = \"Negative\";\n                    // Fixed news count based on crypto type rather than using random numbers\n                    let newsCount;\n                    if (crypto.symbol === \"BTC\") newsCount = 25;\n                    else if (crypto.symbol === \"ETH\") newsCount = 20;\n                    else if ([\n                        \"BNB\",\n                        \"SOL\",\n                        \"ADA\",\n                        \"XRP\"\n                    ].includes(crypto.symbol)) newsCount = 15;\n                    else if ([\n                        \"DOT\",\n                        \"DOGE\",\n                        \"MATIC\",\n                        \"AVAX\",\n                        \"LINK\"\n                    ].includes(crypto.symbol)) newsCount = 12;\n                    else newsCount = 8;\n                    tableRows.push({\n                        project: crypto.name,\n                        tvl: \"N/A\",\n                        tvlChange: \"N/A\",\n                        price: formatCurrency(crypto.price || 0),\n                        priceChange: formatPercentage(priceChange),\n                        sentiment: sentiment,\n                        newsCount: newsCount\n                    });\n                }\n            });\n        }\n        // If still no data, create placeholder data\n        if (tableRows.length === 0) {\n            console.log(\"\\uD83D\\uDCAD Creating placeholder data\");\n            // Default placeholder crypto names\n            const placeholderProjects = [\n                \"Bitcoin\",\n                \"Ethereum\",\n                \"BNB\",\n                \"Solana\",\n                \"Cardano\"\n            ];\n            // Add placeholder data with consistent, non-random sentiment values\n            // Use predefined sentiments based on the project name to ensure consistency\n            const projectSentiments = {\n                \"Bitcoin\": \"Positive\",\n                \"Ethereum\": \"Positive\",\n                \"BNB\": \"Neutral\",\n                \"Solana\": \"Positive\",\n                \"Cardano\": \"Neutral\"\n            };\n            placeholderProjects.forEach((project)=>{\n                // Use predefined sentiment or default to Neutral\n                const sentiment = projectSentiments[project] || \"Neutral\";\n                // Use fixed news count values instead of random numbers\n                const newsCount = project === \"Bitcoin\" ? 25 : project === \"Ethereum\" ? 20 : project === \"BNB\" ? 15 : project === \"Solana\" ? 12 : project === \"Cardano\" ? 10 : 8;\n                tableRows.push({\n                    project: project,\n                    tvl: \"N/A\",\n                    tvlChange: \"N/A\",\n                    price: \"N/A\",\n                    priceChange: \"N/A\",\n                    sentiment: sentiment,\n                    newsCount: newsCount\n                });\n            });\n        }\n        console.log(`✅ Generated ${tableRows.length} table rows`);\n    } catch (error) {\n        console.error(\"Error generating data table:\", error);\n    }\n    return tableRows;\n}\n// Helper functions for formatting\nfunction formatCurrency(value) {\n    if (typeof value !== \"number\" || isNaN(value)) return \"N/A\";\n    if (value >= 1e9) {\n        return `$${(value / 1e9).toFixed(2)}B`;\n    } else if (value >= 1e6) {\n        return `$${(value / 1e6).toFixed(2)}M`;\n    } else if (value >= 1e3) {\n        return `$${(value / 1e3).toFixed(2)}K`;\n    } else {\n        return `$${value.toFixed(2)}`;\n    }\n}\nfunction formatPercentage(value) {\n    if (typeof value !== \"number\" || isNaN(value)) return \"0%\";\n    return `${value > 0 ? \"+\" : \"\"}${value.toFixed(2)}%`;\n}\nasync function analyzeCryptoData(query, data) {\n    console.log(\"\\uD83D\\uDD0D Fetching data for query:\", query);\n    console.log(\"\\uD83D\\uDD52 Query timestamp:\", new Date().toISOString());\n    // Extract focus tokens and projects\n    const focusTokens = extractTokens(query);\n    const focusProjects = extractProjects(query);\n    const timeFrame = extractTimeFrame(query);\n    const useTrending = query.toLowerCase().includes(\"trending\") || query.toLowerCase().includes(\"popular\");\n    const useRandomOrder = !focusTokens.length && !focusProjects.length;\n    console.log(\"\\uD83C\\uDFAF Focus tokens:\", focusTokens);\n    console.log(\"\\uD83C\\uDFAF Focus projects:\", focusProjects);\n    console.log(\"⏰ Time frame:\", timeFrame);\n    console.log(\"\\uD83D\\uDCC8 Using trending data:\", useTrending);\n    console.log(\"\\uD83D\\uDD04 Using random order:\", useRandomOrder);\n    try {\n        // Fetch data\n        const allData = await (0,_api__WEBPACK_IMPORTED_MODULE_0__.fetchAllData)(query);\n        console.log(\"\\uD83D\\uDCCA Fetched data summary:\", {\n            cryptoDataCount: allData.cryptoData?.length || 0,\n            defiProjectsCount: allData.defiProjects?.length || 0\n        });\n        // Generate analysis using Groq with fallback models\n        const analysis = await generateAnalysisWithFallback(query, allData);\n        // Transform data to match ResearchResult interface\n        const transformedData = {\n            cryptoData: allData.cryptoData || [],\n            defiProjects: allData.defiProjects || [],\n            socialSentiment: allData.socialSentiment || [],\n            newsEvents: allData.newsEvents || [],\n            etherscanData: allData.etherscanData || undefined\n        };\n        // Refine data table for explicit comparison queries (e.g., \"Compare Ethereum and Solana\")\n        const refinedTable = refineComparisonTable(query, transformedData, analysis.dataTable || []);\n        return {\n            summary: analysis.summary,\n            data: transformedData,\n            dataTable: refinedTable,\n            sources: analysis.sources,\n            timestamp: new Date().toISOString(),\n            showDeFi: Boolean(allData.defiProjects && allData.defiProjects.length > 0),\n            showTable: Boolean(analysis.dataTable && analysis.dataTable.length > 0),\n            showEtherscan: Boolean(allData.etherscanData && Object.keys(allData.etherscanData || {}).length > 0),\n            isCryptoQuery: true,\n            insights: analysis.insights || [],\n            riskFactors: analysis.riskFactors || [],\n            marketTrends: analysis.marketTrends || \"\"\n        };\n    } catch (error) {\n        console.error(\"❌ Error in analyzeCryptoData:\", error);\n        // Return a basic fallback response\n        return {\n            summary: `Analysis completed. ${error instanceof Error ? error.message : \"Unknown error occurred\"}`,\n            data: {},\n            sources: [\n                \"Fallback Analysis\"\n            ],\n            timestamp: new Date().toISOString(),\n            showDeFi: false,\n            showTable: false,\n            showEtherscan: false,\n            isCryptoQuery: true,\n            insights: [\n                \"Analysis completed with basic method\"\n            ],\n            riskFactors: [\n                \"Use standard mode for more reliable responses\"\n            ],\n            marketTrends: \"Unable to complete full analysis\"\n        };\n    }\n}\nasync function generateAnalysisWithFallback(query, data, maxRetries = 3) {\n    for(let attempt = 1; attempt <= maxRetries; attempt++){\n        try {\n            console.log(`Attempting Groq API call (attempt ${attempt}/${maxRetries})...`);\n            const model = getGroqModel();\n            console.log(`Using model: ${model} (retry attempt: ${attempt - 1})`);\n            const groq = new groq_sdk__WEBPACK_IMPORTED_MODULE_1__.Groq({\n                apiKey: process.env.GROQ_API_KEY\n            });\n            // --- DATA REDUCTION / TOKEN BUDGETING ---------------------------------\n            // We aggressively trim the dataset before sending to the model to avoid 413\n            const reduced = reduceDataForModel(data, query, attempt);\n            const reducedJson = JSON.stringify(reduced); // no pretty print to save tokens\n            const approxInputTokens = Math.ceil(reducedJson.length / 4); // rough heuristic\n            console.log(`🗜️ Reduced data length: ${reducedJson.length} chars (~${approxInputTokens} tokens)`);\n            if (approxInputTokens > 5500) {\n                console.warn(\"⚠️ Still above safe token budget after reduction – applying hard trim\");\n                // Hard trim: keep only essential aggregates\n                const hardTrim = {\n                    meta: reduced.meta,\n                    aggregates: reduced.aggregates,\n                    topCrypto: reduced.cryptoData?.slice(0, 5),\n                    topDeFi: reduced.defiProjects?.slice(0, 5),\n                    news: reduced.newsEvents?.slice(0, 5)?.map((n)=>({\n                            t: n.title,\n                            d: n.publishedAt\n                        }))\n                };\n                const hardTrimJson = JSON.stringify(hardTrim);\n                console.log(`🪓 Hard trimmed length: ${hardTrimJson.length} chars (~${Math.ceil(hardTrimJson.length / 4)} tokens)`);\n            }\n            const systemPrompt = \"You are an expert crypto analyst. Respond ONLY with a minified JSON object. No markdown, no commentary.\";\n            const userPrompt = `Query: ${query}\\nData:${reducedJson}\\nReturn JSON with keys: summary (string), insights (string[] max 6), riskFactors (string[] max 6), marketTrends (string), sources (string[]), dataTable (rows <= 10, fields: project,tvl,tvlChange,price,priceChange,sentiment,newsCount).`;\n            const completion = await groq.chat.completions.create({\n                messages: [\n                    {\n                        role: \"system\",\n                        content: systemPrompt\n                    },\n                    {\n                        role: \"user\",\n                        content: userPrompt\n                    }\n                ],\n                model,\n                temperature: 0.1,\n                max_tokens: 1400,\n                top_p: 1,\n                stream: false\n            });\n            const response = completion.choices[0]?.message?.content;\n            if (!response) {\n                throw new Error(\"Empty response from Groq\");\n            }\n            // Try to parse JSON from the response\n            try {\n                const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n                if (jsonMatch) {\n                    return JSON.parse(jsonMatch[0]);\n                }\n            } catch (parseError) {\n                console.warn(\"JSON parsing failed, using text response\");\n            }\n            // Fallback: create structured response from text\n            return {\n                summary: response,\n                insights: [\n                    \"Analysis completed successfully\"\n                ],\n                riskFactors: [\n                    \"Consider market volatility\"\n                ],\n                marketTrends: \"Market analysis completed\",\n                sources: [\n                    \"Groq AI Analysis\"\n                ],\n                dataTable: []\n            };\n        } catch (error) {\n            console.error(`Groq API error (${error.status === 429 ? \"rate limit\" : \"general error\"}):`, error.status, error.message);\n            // Handle payload too large / token limit message (413 or token size notice)\n            const msg = error?.message || \"\";\n            if (error.status === 413 || msg.includes(\"Request too large\") || msg.includes(\"tokens per minute\")) {\n                console.warn(\"\\uD83D\\uDD01 Oversized request detected, further reducing data & switching model\");\n                nextModel();\n                if (attempt < maxRetries) {\n                    await new Promise((r)=>setTimeout(r, 500 * attempt));\n                    continue;\n                }\n            }\n            if (error.status === 429) {\n                console.log(\"Rate limit hit, trying next model...\");\n                nextModel();\n                if (attempt < maxRetries) {\n                    const delay = Math.min(1000 * Math.pow(2, attempt), 10000);\n                    console.log(`Retrying in ${delay}ms with model fallback...`);\n                    await new Promise((resolve)=>setTimeout(resolve, delay));\n                    continue;\n                }\n            } else if (error.status === 404) {\n                console.log(\"Model not found, trying next model...\");\n                nextModel();\n                if (attempt < maxRetries) {\n                    const delay = 2000 * attempt;\n                    console.log(`Retrying in ${delay}ms with model fallback...`);\n                    await new Promise((resolve)=>setTimeout(resolve, delay));\n                    continue;\n                }\n            }\n            throw error;\n        }\n    }\n    throw new Error(\"All Groq models failed\");\n}\n// Reduce raw fetched data to a compact, model-friendly subset.\nfunction reduceDataForModel(data, query, attempt) {\n    try {\n        const qLower = (query || \"\").toLowerCase();\n        const focusTokens = extractTokens(query || \"\");\n        const maxDeFi = attempt === 1 ? 15 : attempt === 2 ? 10 : 5;\n        const maxCrypto = attempt === 1 ? 12 : attempt === 2 ? 8 : 5;\n        const maxNews = attempt === 1 ? 20 : attempt === 2 ? 10 : 5;\n        const cryptoData = (data.cryptoData || []).filter((c)=>focusTokens.length ? focusTokens.includes(c.symbol) : true).sort((a, b)=>(b.marketCap || 0) - (a.marketCap || 0)).slice(0, maxCrypto).map((c)=>({\n                symbol: c.symbol,\n                name: c.name,\n                price: c.price,\n                priceChange24h: c.priceChange24h,\n                marketCap: c.marketCap,\n                volume24h: c.volume24h\n            }));\n        const defiProjects = (data.defiProjects || []).sort((a, b)=>(b.tvl || 0) - (a.tvl || 0)).slice(0, maxDeFi).map((p)=>({\n                name: p.name,\n                tvl: p.tvl,\n                tvlChange24h: p.tvlChange24h,\n                tvlChange7d: p.tvlChange7d,\n                chains: p.chains?.slice(0, 5)\n            }));\n        const newsEvents = (data.newsEvents || []).slice(0, maxNews).map((n)=>({\n                title: n.title,\n                sentiment: n.sentiment,\n                publishedAt: n.publishedAt\n            }));\n        const etherscanGas = data.etherscanData?.gasPrice ? {\n            LastBlock: data.etherscanData.gasPrice.LastBlock,\n            SafeGasPrice: data.etherscanData.gasPrice.SafeGasPrice,\n            Fast: data.etherscanData.gasPrice.Fast\n        } : undefined;\n        // Aggregates to help model without full raw arrays\n        const tvlTotal = (data.defiProjects || []).reduce((s, p)=>s + (p.tvl || 0), 0);\n        const avgPriceChange = cryptoData.length ? cryptoData.reduce((s, c)=>s + (c.priceChange24h || 0), 0) / cryptoData.length : 0;\n        const generatedTable = generateDataTableFromRawData({\n            defiProjects,\n            cryptoData,\n            newsEvents\n        }, query).slice(0, 10); // ensure max 10 rows\n        return {\n            meta: {\n                attempt,\n                focusTokens,\n                queryFragment: query.slice(0, 160)\n            },\n            aggregates: {\n                tvlTotal,\n                avgPriceChange: Number(avgPriceChange.toFixed(2)),\n                defiCount: (data.defiProjects || []).length,\n                cryptoCount: (data.cryptoData || []).length,\n                newsCount: (data.newsEvents || []).length\n            },\n            cryptoData,\n            defiProjects,\n            newsEvents,\n            etherscan: etherscanGas,\n            // Provide already generated dataTable to reduce model work\n            suggestedTable: generatedTable\n        };\n    } catch (e) {\n        console.warn(\"reduceDataForModel failed, returning minimal structure\", e);\n        return {\n            meta: {\n                attempt,\n                error: true\n            },\n            cryptoData: [],\n            defiProjects: []\n        };\n    }\n}\n// Fallback function to generate a clean summary from available data\nfunction generateFallbackSummary(data, query) {\n    let summary = \"\";\n    try {\n        // Extract query keywords to make the response more relevant\n        const queryLower = query.toLowerCase();\n        const mentionsBitcoin = queryLower.includes(\"bitcoin\") || queryLower.includes(\"btc\");\n        const mentionsEthereum = queryLower.includes(\"ethereum\") || queryLower.includes(\"eth\");\n        const mentionsDeFi = queryLower.includes(\"defi\") || queryLower.includes(\"protocol\") || queryLower.includes(\"tvl\");\n        const mentionsPrice = queryLower.includes(\"price\") || queryLower.includes(\"market\") || queryLower.includes(\"trading\");\n        const mentionsTop = queryLower.includes(\"top\") || queryLower.includes(\"best\") || queryLower.includes(\"leading\");\n        // Add personalized intro based on the query\n        summary += `Based on your query about ${mentionsDeFi ? \"DeFi protocols\" : mentionsBitcoin ? \"Bitcoin\" : mentionsEthereum ? \"Ethereum\" : \"the crypto market\"}, here's my analysis: \\n\\n`;\n        // Add DeFi projects analysis\n        if (data.defiProjects && Array.isArray(data.defiProjects) && data.defiProjects.length > 0) {\n            const topProjects = data.defiProjects.slice(0, 3);\n            summary += `Analysis of the DeFi market reveals ${data.defiProjects.length} active protocols. `;\n            if (mentionsTop || !mentionsPrice) {\n                summary += `The top performers by Total Value Locked (TVL) include ${topProjects.map((p)=>p?.name || \"Unknown\").join(\", \")}. `;\n            }\n            const totalTVL = data.defiProjects.reduce((sum, p)=>sum + (p?.tvl || 0), 0);\n            if (totalTVL > 0) {\n                summary += `Total Value Locked across all protocols is approximately $${(totalTVL / 1e9).toFixed(1)}B. `;\n            }\n            // Add TVL change analysis if we have that data\n            const projectsWithTVLChange = data.defiProjects.filter((p)=>typeof p.tvlChange7d === \"number\" || typeof p.tvlChange24h === \"number\");\n            if (projectsWithTVLChange.length > 0) {\n                // Sort by TVL change\n                const sortedByChange = [\n                    ...projectsWithTVLChange\n                ].sort((a, b)=>(b.tvlChange7d || b.tvlChange24h || 0) - (a.tvlChange7d || a.tvlChange24h || 0));\n                const topGainer = sortedByChange[0];\n                const topLoser = sortedByChange[sortedByChange.length - 1];\n                if (topGainer && (topGainer.tvlChange7d > 0 || topGainer.tvlChange24h > 0)) {\n                    const changeValue = topGainer.tvlChange7d || topGainer.tvlChange24h;\n                    summary += `${topGainer.name} shows the highest growth with a ${changeValue.toFixed(2)}% increase in TVL. `;\n                }\n                if (topLoser && (topLoser.tvlChange7d < 0 || topLoser.tvlChange24h < 0)) {\n                    const changeValue = topLoser.tvlChange7d || topLoser.tvlChange24h;\n                    summary += `${topLoser.name} has experienced a ${Math.abs(changeValue).toFixed(2)}% decrease in TVL. `;\n                }\n            }\n        }\n        // Add crypto market data\n        if (data.cryptoData && Array.isArray(data.cryptoData) && data.cryptoData.length > 0) {\n            // Get current date for context\n            const now = new Date();\n            const dateStr = now.toLocaleDateString(\"en-US\", {\n                month: \"long\",\n                day: \"numeric\",\n                year: \"numeric\"\n            });\n            summary += `\\nAs of ${dateStr}, `;\n            const btc = data.cryptoData.find((c)=>c?.symbol === \"BTC\");\n            const eth = data.cryptoData.find((c)=>c?.symbol === \"ETH\");\n            if (btc && typeof btc.price === \"number\") {\n                summary += `Bitcoin is currently trading at $${btc.price.toLocaleString(undefined, {\n                    maximumFractionDigits: 2\n                })}`;\n                if (typeof btc.priceChange24h === \"number\") {\n                    summary += ` with a 24h change of ${btc.priceChange24h > 0 ? \"+\" : \"\"}${btc.priceChange24h.toFixed(2)}%. `;\n                } else {\n                    summary += \". \";\n                }\n            }\n            if (eth && typeof eth.price === \"number\") {\n                summary += `Ethereum is trading at $${eth.price.toLocaleString(undefined, {\n                    maximumFractionDigits: 2\n                })}`;\n                if (typeof eth.priceChange24h === \"number\") {\n                    summary += ` with a 24h change of ${eth.priceChange24h > 0 ? \"+\" : \"\"}${eth.priceChange24h.toFixed(2)}%. `;\n                } else {\n                    summary += \". \";\n                }\n            }\n            // Add analysis of other notable cryptocurrencies\n            const otherCryptos = data.cryptoData.filter((c)=>c?.symbol !== \"BTC\" && c?.symbol !== \"ETH\" && typeof c?.price === \"number\" && typeof c?.priceChange24h === \"number\");\n            if (otherCryptos.length > 0) {\n                // Sort by price change to find biggest gainers/losers\n                const sortedByChange = [\n                    ...otherCryptos\n                ].sort((a, b)=>b.priceChange24h - a.priceChange24h);\n                // Grab top gainer and loser\n                const topGainer = sortedByChange[0];\n                const topLoser = sortedByChange[sortedByChange.length - 1];\n                summary += `\\n\\nAmong altcoins, `;\n                if (topGainer && topGainer.priceChange24h > 0) {\n                    summary += `${topGainer.name} (${topGainer.symbol}) is the top performer with a ${topGainer.priceChange24h > 0 ? \"+\" : \"\"}${topGainer.priceChange24h.toFixed(2)}% price change, currently at $${topGainer.price.toLocaleString(undefined, {\n                        maximumFractionDigits: 2\n                    })}. `;\n                }\n                if (topLoser && topLoser.priceChange24h < 0) {\n                    summary += `${topLoser.name} (${topLoser.symbol}) shows the largest decline at ${topLoser.priceChange24h.toFixed(2)}%, trading at $${topLoser.price.toLocaleString(undefined, {\n                        maximumFractionDigits: 2\n                    })}. `;\n                }\n            }\n        }\n        // Add conclusion and recommendations\n        summary += `\\n\\nIn summary, ${generateDynamicConclusion(query, data)}`;\n    } catch (error) {\n        console.error(\"Error in generateFallbackSummary:\", error);\n        summary = \"Analysis completed with available data. Some sources may be unavailable.\";\n    }\n    return summary || \"Analysis completed with available data. Some sources may be unavailable.\";\n}\n// Generate a dynamic conclusion based on the query and data\nfunction generateDynamicConclusion(query, data) {\n    const queryLower = query.toLowerCase();\n    let conclusion = \"\";\n    // Check if market is mostly up or down\n    let positiveChanges = 0;\n    let negativeChanges = 0;\n    // Count price changes direction\n    if (data.cryptoData && Array.isArray(data.cryptoData)) {\n        data.cryptoData.forEach((crypto)=>{\n            if (crypto?.priceChange24h > 0) positiveChanges++;\n            else if (crypto?.priceChange24h < 0) negativeChanges++;\n        });\n    }\n    // Count TVL changes direction\n    if (data.defiProjects && Array.isArray(data.defiProjects)) {\n        data.defiProjects.forEach((project)=>{\n            const change = project?.tvlChange24h || project?.tvlChange7d;\n            if (change > 0) positiveChanges++;\n            else if (change < 0) negativeChanges++;\n        });\n    }\n    const marketSentiment = positiveChanges > negativeChanges ? \"positive\" : negativeChanges > positiveChanges ? \"negative\" : \"mixed\";\n    // Generate conclusion based on query type\n    if (queryLower.includes(\"invest\") || queryLower.includes(\"buy\")) {\n        switch(marketSentiment){\n            case \"positive\":\n                conclusion = \"the market is showing mostly positive momentum. Consider researching projects with strong fundamentals and consistent growth before making investment decisions. Always diversify your portfolio and invest only what you can afford to lose.\";\n                break;\n            case \"negative\":\n                conclusion = \"the market is showing some bearish signals. Consider waiting for stability or look for projects that have shown resilience during downturns. Risk management should be prioritized in current conditions.\";\n                break;\n            default:\n                conclusion = \"the market shows mixed signals. Focus on projects with strong fundamentals and consider dollar-cost averaging rather than lump-sum investments given the current volatility.\";\n        }\n    } else if (queryLower.includes(\"trend\") || queryLower.includes(\"movement\")) {\n        switch(marketSentiment){\n            case \"positive\":\n                conclusion = \"the current trend appears bullish with most assets showing positive price action. Keep an eye on trading volumes and potential resistance levels that might indicate trend reversals.\";\n                break;\n            case \"negative\":\n                conclusion = \"the trend appears bearish in the short term with several assets showing price declines. Watch for potential support levels where reversals might occur.\";\n                break;\n            default:\n                conclusion = \"we're seeing consolidation across many assets with mixed signals. This often precedes significant market movements, so monitor key technical indicators for breakout signals.\";\n        }\n    } else {\n        switch(marketSentiment){\n            case \"positive\":\n                conclusion = \"the overall crypto market shows strength at the moment. Keep monitoring key resistance levels and news events that might impact this positive trend.\";\n                break;\n            case \"negative\":\n                conclusion = \"caution is advised as several assets are showing downward pressure. Consider watching key support levels and market catalysts that could reverse this trend.\";\n                break;\n            default:\n                conclusion = \"the market lacks clear direction at the moment. This might present opportunities for both entries and exits depending on your investment strategy and risk tolerance.\";\n        }\n    }\n    return conclusion;\n}\n// Refine / filter the data table when the user explicitly asks to compare a small set of tokens/projects.\nfunction refineComparisonTable(query, rawData, existing) {\n    try {\n        const q = query.toLowerCase();\n        if (!/compare|vs|versus/.test(q)) return existing; // only apply on comparison intent\n        // Extract explicit tokens (symbols) and project name words\n        const tokens = extractTokens(query); // returns uppercase symbols\n        const nameTargets = tokens.map((t)=>t.toLowerCase());\n        // Also capture common full names for ETH & BTC etc\n        const extraNameMap = {\n            \"ETH\": [\n                \"ethereum\"\n            ],\n            \"BTC\": [\n                \"bitcoin\"\n            ],\n            \"SOL\": [\n                \"solana\"\n            ],\n            \"BNB\": [\n                \"bnb\",\n                \"binance\"\n            ],\n            \"ADA\": [\n                \"cardano\"\n            ]\n        };\n        tokens.forEach((sym)=>{\n            (extraNameMap[sym] || []).forEach((n)=>nameTargets.push(n));\n        });\n        // If user only mentions two to five items, we restrict to them strictly.\n        if (tokens.length >= 2 && tokens.length <= 6) {\n            const filtered = existing.filter((r)=>{\n                const proj = r.project?.toLowerCase();\n                return nameTargets.some((t)=>proj.includes(t));\n            });\n            // If model returned unrelated rows and we lost everything, rebuild from raw crypto data for those tokens.\n            if (filtered.length === 0) {\n                const rebuilt = [];\n                (rawData.cryptoData || []).forEach((c)=>{\n                    if (tokens.includes(c.symbol)) {\n                        rebuilt.push({\n                            project: c.name,\n                            tvl: \"N/A\",\n                            tvlChange: \"N/A\",\n                            price: typeof c.price === \"number\" ? `$${c.price.toFixed(2)}` : \"N/A\",\n                            priceChange: typeof c.priceChange24h === \"number\" ? `${c.priceChange24h > 0 ? \"+\" : \"\"}${c.priceChange24h.toFixed(2)}%` : \"N/A\",\n                            sentiment: c.priceChange24h > 2 ? \"Positive\" : c.priceChange24h < -2 ? \"Negative\" : \"Neutral\",\n                            newsCount: c.symbol === \"ETH\" ? 20 : c.symbol === \"BTC\" ? 25 : 10\n                        });\n                    }\n                });\n                return rebuilt.slice(0, tokens.length);\n            }\n            // Preserve order of appearance in query by sorting filtered rows accordingly\n            const order = nameTargets;\n            filtered.sort((a, b)=>order.findIndex((t)=>a.project.toLowerCase().includes(t)) - order.findIndex((t)=>b.project.toLowerCase().includes(t)));\n            return filtered.slice(0, tokens.length);\n        }\n        return existing;\n    } catch (e) {\n        console.warn(\"refineComparisonTable failed, returning original table\", e);\n        return existing;\n    }\n}\nasync function generateInsights(query, data) {\n    try {\n        const prompt = `\r\nBased on the following crypto data, provide insights for the query: \"${query}\"\r\n\r\nData: ${JSON.stringify(data, null, 2)}\r\n\r\nProvide a concise, professional analysis focusing on:\r\n- Key trends and patterns\r\n- Notable changes in metrics\r\n- Potential implications for investors\r\n- Risk factors to consider\r\n`;\n        let retryCount = 0;\n        const maxRetries = 2;\n        let retryDelay = 1000; // Start with 1 second delay\n        while(retryCount <= maxRetries){\n            try {\n                const completion = await groq.chat.completions.create({\n                    messages: [\n                        {\n                            role: \"system\",\n                            content: \"You are a crypto market analyst. Provide clear, actionable insights.\"\n                        },\n                        {\n                            role: \"user\",\n                            content: prompt\n                        }\n                    ],\n                    model: getCurrentModel(retryCount),\n                    temperature: 0.3,\n                    max_tokens: 1000\n                });\n                return completion.choices[0]?.message?.content || \"Unable to generate insights at this time.\";\n            } catch (retryError) {\n                const errorMessage = retryError instanceof Error ? retryError.message : \"Unknown error\";\n                const isCapacityError = errorMessage.includes(\"over capacity\");\n                const isRateLimitError = errorMessage.includes(\"rate_limit_exceeded\") || errorMessage.includes(\"Rate limit reached\");\n                console.error(`Groq API error (${isRateLimitError ? \"rate limit\" : isCapacityError ? \"capacity issue\" : \"general error\"}) - attempt ${retryCount + 1}/${maxRetries + 1}:`, retryError);\n                if (retryCount >= maxRetries) {\n                    throw retryError; // Re-throw if we've exhausted retries\n                }\n                // Calculate backoff delay with exponential increase\n                retryDelay *= 2;\n                console.log(`Retrying in ${retryDelay}ms with model fallback...`);\n                await new Promise((resolve)=>setTimeout(resolve, retryDelay));\n                retryCount++;\n            }\n        }\n        // This should never be reached due to the throw in the catch block above\n        return \"Unable to generate insights after multiple attempts.\";\n    } catch (error) {\n        console.error(\"Error generating insights:\", error);\n        // If this is a capacity/server error, update env flag to skip future API calls\n        if (error?.message?.includes(\"over capacity\") || error?.status === 503) {\n            console.log(\"⚠️ Groq API is over capacity, enabling fallback mode\");\n            process.env.SKIP_GROQ_API = \"true\";\n        }\n        // Generate a fallback insight message based on the query type\n        const queryLower = query.toLowerCase();\n        if (queryLower.includes(\"invest\") || queryLower.includes(\"buy\")) {\n            return \"Based on the available data, remember that cryptocurrency investments carry significant risk. Always conduct thorough research, diversify your portfolio, and invest only what you can afford to lose.\";\n        } else if (queryLower.includes(\"trend\") || queryLower.includes(\"market\")) {\n            return \"Market trends show varying patterns across different assets. Focus on fundamentals and long-term potential rather than short-term price movements when evaluating projects.\";\n        } else {\n            return \"The crypto market is constantly evolving. Stay informed about project developments, regulatory changes, and broader market conditions to make better decisions.\";\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvZ3JvcS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdDO0FBRUs7QUFFckMsdUNBQXVDO0FBQ3ZDLFNBQVNFLGNBQWNDLEtBQWE7SUFDbEMsTUFBTUMsU0FBUztRQUFDO1FBQU87UUFBTztRQUFRO1FBQVE7UUFBTztRQUFPO1FBQU87UUFBTztRQUFRO0tBQVE7SUFDMUYsT0FBT0EsT0FBT0MsTUFBTSxDQUFDQyxDQUFBQSxRQUFTSCxNQUFNSSxXQUFXLEdBQUdDLFFBQVEsQ0FBQ0Y7QUFDN0Q7QUFFQSxTQUFTRyxnQkFBZ0JOLEtBQWE7SUFDcEMsTUFBTU8sV0FBVztRQUFDO1FBQVc7UUFBUTtRQUFZO1FBQVM7UUFBUztRQUFTO0tBQWM7SUFDMUYsT0FBT0EsU0FBU0wsTUFBTSxDQUFDTSxDQUFBQSxVQUFXUixNQUFNUyxXQUFXLEdBQUdKLFFBQVEsQ0FBQ0csUUFBUUMsV0FBVztBQUNwRjtBQUVBLFNBQVNDLGlCQUFpQlYsS0FBYTtJQUNyQyxJQUFJQSxNQUFNUyxXQUFXLEdBQUdKLFFBQVEsQ0FBQyxVQUFVTCxNQUFNUyxXQUFXLEdBQUdKLFFBQVEsQ0FBQyxRQUFRLE9BQU87SUFDdkYsSUFBSUwsTUFBTVMsV0FBVyxHQUFHSixRQUFRLENBQUMsV0FBV0wsTUFBTVMsV0FBVyxHQUFHSixRQUFRLENBQUMsT0FBTyxPQUFPO0lBQ3ZGLElBQUlMLE1BQU1TLFdBQVcsR0FBR0osUUFBUSxDQUFDLFlBQVlMLE1BQU1TLFdBQVcsR0FBR0osUUFBUSxDQUFDLFFBQVEsT0FBTztJQUN6RixPQUFPO0FBQ1Q7QUFFQSw4Q0FBOEM7QUFDOUMsTUFBTU0sY0FBYztJQUNsQjtJQUNBO0lBQ0E7SUFDQSxlQUEyQixXQUFXO0NBQ3ZDO0FBRUQsSUFBSUMsb0JBQW9CO0FBRXhCLE1BQU1DLGVBQWU7SUFDbkIsT0FBT0YsV0FBVyxDQUFDQyxrQkFBa0IsSUFBSUQsV0FBVyxDQUFDLEVBQUU7QUFDekQ7QUFFQSxNQUFNRyxZQUFZO0lBQ2hCRixvQkFBb0IsQ0FBQ0Esb0JBQW9CLEtBQUtELFlBQVlJLE1BQU07SUFDaEUsT0FBT0Y7QUFDVDtBQUVBLG9HQUFvRztBQUNwRyxNQUFNRyxPQUFPLElBQUluQiwwQ0FBSUE7QUFFckIsbURBQW1EO0FBQ25ELE1BQU1vQixrQkFBa0I7SUFDdEI7SUFDQTtJQUNBO0lBQ0E7SUFDQSxxQkFBNEIsYUFBYTtDQUMxQztBQUVELGdFQUFnRTtBQUNoRSxTQUFTQyxnQkFBZ0JDLGFBQXFCLENBQUM7SUFDN0MsaUVBQWlFO0lBQ2pFLE1BQU1DLFFBQVFDLEtBQUtDLEdBQUcsQ0FBQ0gsWUFBWUYsZ0JBQWdCRixNQUFNLEdBQUc7SUFDNUQsTUFBTVEsUUFBUU4sZUFBZSxDQUFDRyxNQUFNO0lBQ3BDSSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxhQUFhLEVBQUVGLE1BQU0saUJBQWlCLEVBQUVKLFdBQVcsQ0FBQyxDQUFDO0lBQ2xFLE9BQU9JO0FBQ1Q7QUFFQSxTQUFTRyxjQUFjMUIsS0FBYTtJQUNsQyxNQUFNMkIsSUFBSTNCLE1BQU1TLFdBQVc7SUFFM0IsbUNBQW1DO0lBQ25DLE1BQU1tQixrQkFBa0Isb3BHQUFvcEdDLElBQUksQ0FBQ0Y7SUFFanJHLDBDQUEwQztJQUMxQyxJQUFJLENBQUNDLGlCQUFpQjtRQUNwQixPQUFPO1lBQ0xFLFVBQVU7WUFDVkMsV0FBVztZQUNYQyxlQUFlO1FBQ2pCO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xGLFVBQVUsMkRBQTJERCxJQUFJLENBQUNGO1FBQzFFSSxXQUFXLHFEQUFxREYsSUFBSSxDQUFDRjtRQUNyRU0sZUFBZSxnRkFBZ0ZKLElBQUksQ0FBQ0Y7UUFDcEdLLGVBQWU7SUFDakI7QUFDRjtBQUVBLHlFQUF5RTtBQUN6RSxTQUFTRSw2QkFBNkJDLElBQVMsRUFBRW5DLFFBQWdCLEVBQUU7SUFDakV3QixRQUFRQyxHQUFHLENBQUMsK0RBQXFEekI7SUFDakV3QixRQUFRQyxHQUFHLENBQUMsc0NBQTRCO1FBQ3RDVyxtQkFBbUJELEtBQUtFLFlBQVksRUFBRXRCLFVBQVU7UUFDaER1QixpQkFBaUJILEtBQUtJLFVBQVUsRUFBRXhCLFVBQVU7SUFDOUM7SUFFQSxNQUFNeUIsWUFBNEIsRUFBRTtJQUVwQyxJQUFJO1FBQ0YscUNBQXFDO1FBQ3JDLE1BQU1DLGVBQWVOLEtBQUtNLFlBQVksSUFBSTtZQUN4Q0MsV0FBVztZQUNYQyxNQUFNO1lBQ05DLGFBQWE7UUFDZjtRQUVBLGlFQUFpRTtRQUNqRSxNQUFNQyxzQkFBaUQ7WUFDckQsV0FBVztZQUNYLFFBQVE7WUFDUixZQUFZO1lBQ1osWUFBWTtZQUNaLFFBQVE7WUFDUixTQUFTO1lBQ1QsYUFBYTtZQUNiLGlCQUFpQjtZQUNqQixhQUFhO1lBQ2IsZUFBZTtZQUNmLFlBQVk7WUFDWixTQUFTO1FBQ1g7UUFFQSxnRUFBZ0U7UUFDaEUsSUFBSVYsS0FBS0UsWUFBWSxJQUFJUyxNQUFNQyxPQUFPLENBQUNaLEtBQUtFLFlBQVksR0FBRztZQUN6RGIsUUFBUUMsR0FBRyxDQUFDO1lBRVosdUNBQXVDO1lBQ3ZDLElBQUl1QixpQkFBaUI7bUJBQUliLEtBQUtFLFlBQVk7YUFBQztZQUUzQywrQ0FBK0M7WUFDL0MsSUFBSXJDLE1BQU1TLFdBQVcsR0FBR0osUUFBUSxDQUFDLFVBQVVMLE1BQU1TLFdBQVcsR0FBR0osUUFBUSxDQUFDLGFBQWFMLE1BQU1TLFdBQVcsR0FBR0osUUFBUSxDQUFDLFVBQVU7Z0JBQzFILElBQUlMLE1BQU1TLFdBQVcsR0FBR0osUUFBUSxDQUFDLGNBQWNMLE1BQU1TLFdBQVcsR0FBR0osUUFBUSxDQUFDLFVBQVVMLE1BQU1TLFdBQVcsR0FBR0osUUFBUSxDQUFDLFNBQVM7b0JBQzFILHlCQUF5QjtvQkFDekIyQyxlQUFlQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDQSxFQUFFQyxHQUFHLElBQUksS0FBTUYsQ0FBQUEsRUFBRUUsR0FBRyxJQUFJO2dCQUN6RCxPQUFPLElBQUlwRCxNQUFNUyxXQUFXLEdBQUdKLFFBQVEsQ0FBQyxhQUFhTCxNQUFNUyxXQUFXLEdBQUdKLFFBQVEsQ0FBQyxhQUFhTCxNQUFNUyxXQUFXLEdBQUdKLFFBQVEsQ0FBQyxVQUFVO29CQUNwSSxxQkFBcUI7b0JBQ3JCMkMsZUFBZUMsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQ3JCLENBQUNBLEVBQUVFLFdBQVcsSUFBSUYsRUFBRUcsWUFBWSxJQUFJLEtBQU1KLENBQUFBLEVBQUVHLFdBQVcsSUFBSUgsRUFBRUksWUFBWSxJQUFJO2dCQUVsRjtZQUNGO1lBRUEsMERBQTBEO1lBQzFELE1BQU1DLFFBQVF2RCxNQUFNUyxXQUFXLEdBQUdKLFFBQVEsQ0FBQyxZQUFZLEtBQ3pDTCxNQUFNUyxXQUFXLEdBQUdKLFFBQVEsQ0FBQyxXQUFXLElBQ3hDZ0IsS0FBS0MsR0FBRyxDQUFDLElBQUltQixhQUFhRSxJQUFJLElBQUk7WUFFaERLLGVBQWVRLEtBQUssQ0FBQyxHQUFHRCxPQUFPRSxPQUFPLENBQUMsQ0FBQ2pELFNBQWNZO2dCQUNwRCxJQUFJWixXQUFXQSxRQUFRa0QsSUFBSSxFQUFFO29CQUN6Qiw2REFBNkQ7b0JBQy9ELE1BQU1DLGNBQWNkLG1CQUFtQixDQUFDckMsUUFBUWtELElBQUksQ0FBQyxJQUFJbEQsUUFBUW9ELE1BQU07b0JBQ3ZFLE1BQU1yQixhQUFhSixLQUFLSSxVQUFVLEVBQUVzQixLQUFLLENBQUNDLElBQ3hDQSxHQUFHRixRQUFRbkQsa0JBQWtCa0QsYUFBYWxELGlCQUMxQ3FELEdBQUdGLFFBQVFuRCxrQkFBa0JELFFBQVFvRCxNQUFNLEVBQUVuRCxpQkFDN0NxRCxHQUFHSixNQUFNakQsY0FBY0osU0FBU0csUUFBUWtELElBQUksQ0FBQ2pELFdBQVcsT0FDeERELFFBQVFrRCxJQUFJLENBQUNqRCxXQUFXLEdBQUdKLFFBQVEsQ0FBQ3lELEdBQUdKLE1BQU1qRDtvQkFHL0MsSUFBSVcsUUFBUSxHQUFHO3dCQUNiSSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUVqQixRQUFRa0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFOzRCQUN6Q0M7NEJBQ0FJLGFBQWEsQ0FBQyxDQUFDeEI7NEJBQ2Z5QixhQUFhekIsWUFBWTBCO3dCQUMzQjtvQkFDRjtvQkFFQSw4REFBOEQ7b0JBQzlELE1BQU1DLHdCQUFtRDt3QkFDdkQsV0FBVzt3QkFDWCxRQUFRO3dCQUNSLFlBQVk7d0JBQ1osWUFBWTt3QkFDWixTQUFTO3dCQUNULFFBQVE7d0JBQ1IsYUFBYTt3QkFDYixpQkFBaUI7d0JBQ2pCLGFBQWE7d0JBQ2IsZUFBZTt3QkFDZixZQUFZO3dCQUNaLFNBQVM7b0JBQ1g7b0JBRUEsd0JBQXdCO29CQUN4QixNQUFNQyxjQUFjNUIsWUFBWTZCLGtCQUFrQjtvQkFDbEQsTUFBTUMsWUFBWTdELFFBQVE2QyxXQUFXLElBQUk3QyxRQUFROEMsWUFBWSxJQUFJO29CQUVqRSw2REFBNkQ7b0JBQzdELElBQUlnQixZQUFZSixxQkFBcUIsQ0FBQzFELFFBQVFrRCxJQUFJLENBQUMsSUFBSTtvQkFFdkQsd0RBQXdEO29CQUN4RCxJQUFJLENBQUNRLHFCQUFxQixDQUFDMUQsUUFBUWtELElBQUksQ0FBQyxFQUFFO3dCQUN4QywrQ0FBK0M7d0JBQy9DLElBQUluQixjQUFlNEIsQ0FBQUEsZ0JBQWdCLEtBQUtFLGNBQWMsSUFBSTs0QkFDeEQsNkNBQTZDOzRCQUM3QyxNQUFNRSxpQkFBaUJoQyxhQUFjNEIsY0FBYyxNQUFNRSxZQUFZLE1BQU9BOzRCQUU1RSxJQUFJRSxpQkFBaUIsS0FBS0QsWUFBWTtpQ0FDakMsSUFBSUMsaUJBQWlCLENBQUMsS0FBS0QsWUFBWTt3QkFDOUM7b0JBQ0Y7b0JBRUEsZ0VBQWdFO29CQUNoRSxJQUFJRTtvQkFFSixvQ0FBb0M7b0JBQ3BDLElBQUlyQyxLQUFLc0MsVUFBVSxJQUFJM0IsTUFBTUMsT0FBTyxDQUFDWixLQUFLc0MsVUFBVSxLQUFLdEMsS0FBS3NDLFVBQVUsQ0FBQzFELE1BQU0sR0FBRyxHQUFHO3dCQUNuRiw0Q0FBNEM7d0JBQzVDLE1BQU0yRCxjQUFjdkMsS0FBS3NDLFVBQVUsQ0FBQ3ZFLE1BQU0sQ0FBQyxDQUFDeUUsT0FDMUNBLEtBQUtDLEtBQUssQ0FBQ3ZFLFFBQVEsQ0FBQ0csUUFBUWtELElBQUksS0FDL0JsRCxRQUFRb0QsTUFBTSxJQUFJZSxLQUFLQyxLQUFLLENBQUN2RSxRQUFRLENBQUNHLFFBQVFvRCxNQUFNO3dCQUV2RFksWUFBWUUsWUFBWTNELE1BQU07d0JBRTlCLGtEQUFrRDt3QkFDbEQsSUFBSXlELGNBQWMsR0FBRzs0QkFDbkJBLFlBQVluRCxLQUFLd0QsS0FBSyxDQUFDeEQsS0FBS3lELE1BQU0sS0FBSyxLQUFLO3dCQUM5QztvQkFDRixPQUFPO3dCQUNMLDhFQUE4RTt3QkFDOUUsTUFBTUMsZ0JBQWdCMUQsS0FBS3dELEtBQUssQ0FBQyxJQUFJLENBQUNyRSxRQUFRNEMsR0FBRyxJQUFJLEtBQUssTUFBTyx1QkFBdUI7d0JBQ3hGb0IsWUFBWW5ELEtBQUtDLEdBQUcsQ0FBQyxJQUFJRCxLQUFLMkQsR0FBRyxDQUFDLEdBQ2hDRCxnQkFBaUIxRCxDQUFBQSxLQUFLNEQsR0FBRyxDQUFDWixhQUFhLElBQUksS0FBSyxFQUFJLHFDQUFxQzt3QkFBekM7b0JBRXBEO29CQUVBN0IsVUFBVTBDLElBQUksQ0FBQzt3QkFDYjFFLFNBQVNBLFFBQVFrRCxJQUFJO3dCQUNyQk4sS0FBSytCLGVBQWUzRSxRQUFRNEMsR0FBRyxJQUFJO3dCQUNuQ2lCLFdBQVdlLGlCQUFpQmY7d0JBQzVCSixPQUFPMUIsYUFBYTRDLGVBQWU1QyxXQUFXMEIsS0FBSyxJQUFJLEtBQUs7d0JBQzVERSxhQUFhNUIsYUFBYTZDLGlCQUFpQmpCLGVBQWU7d0JBQzFERyxXQUFXQTt3QkFDWEUsV0FBV0E7b0JBQ2I7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsK0RBQStEO1FBQy9ELElBQUloQyxVQUFVekIsTUFBTSxLQUFLLEtBQUtvQixLQUFLSSxVQUFVLElBQUlPLE1BQU1DLE9BQU8sQ0FBQ1osS0FBS0ksVUFBVSxHQUFHO1lBQy9FZixRQUFRQyxHQUFHLENBQUM7WUFDWlUsS0FBS0ksVUFBVSxDQUFDaUIsS0FBSyxDQUFDLEdBQUcsSUFBSUMsT0FBTyxDQUFDLENBQUM0QjtnQkFDcEMsSUFBSUEsVUFBVUEsT0FBTzNCLElBQUksRUFBRTtvQkFDekIsa0VBQWtFO29CQUNsRSxJQUFJWSxZQUFZO29CQUNoQixNQUFNSCxjQUFja0IsT0FBT2pCLGNBQWMsSUFBSTtvQkFFN0Msd0RBQXdEO29CQUN4RCxJQUFJRCxjQUFjLEtBQUtHLFlBQVk7eUJBQzlCLElBQUlILGNBQWMsQ0FBQyxLQUFLRyxZQUFZO29CQUV6Qyx5RUFBeUU7b0JBQ3pFLElBQUlFO29CQUNKLElBQUlhLE9BQU96QixNQUFNLEtBQUssT0FBT1ksWUFBWTt5QkFDcEMsSUFBSWEsT0FBT3pCLE1BQU0sS0FBSyxPQUFPWSxZQUFZO3lCQUN6QyxJQUFJO3dCQUFDO3dCQUFPO3dCQUFPO3dCQUFPO3FCQUFNLENBQUNuRSxRQUFRLENBQUNnRixPQUFPekIsTUFBTSxHQUFHWSxZQUFZO3lCQUN0RSxJQUFJO3dCQUFDO3dCQUFPO3dCQUFRO3dCQUFTO3dCQUFRO3FCQUFPLENBQUNuRSxRQUFRLENBQUNnRixPQUFPekIsTUFBTSxHQUFHWSxZQUFZO3lCQUNsRkEsWUFBWTtvQkFFakJoQyxVQUFVMEMsSUFBSSxDQUFDO3dCQUNiMUUsU0FBUzZFLE9BQU8zQixJQUFJO3dCQUNwQk4sS0FBSzt3QkFDTGlCLFdBQVc7d0JBQ1hKLE9BQU9rQixlQUFlRSxPQUFPcEIsS0FBSyxJQUFJO3dCQUN0Q0UsYUFBYWlCLGlCQUFpQmpCO3dCQUM5QkcsV0FBV0E7d0JBQ1hFLFdBQVdBO29CQUNiO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLDRDQUE0QztRQUM1QyxJQUFJaEMsVUFBVXpCLE1BQU0sS0FBSyxHQUFHO1lBQzFCUyxRQUFRQyxHQUFHLENBQUM7WUFFWixtQ0FBbUM7WUFDbkMsTUFBTTZELHNCQUFzQjtnQkFBQztnQkFBVztnQkFBWTtnQkFBTztnQkFBVTthQUFVO1lBRS9FLG9FQUFvRTtZQUNwRSw0RUFBNEU7WUFDNUUsTUFBTUMsb0JBQStDO2dCQUNuRCxXQUFXO2dCQUNYLFlBQVk7Z0JBQ1osT0FBTztnQkFDUCxVQUFVO2dCQUNWLFdBQVc7WUFDYjtZQUVBRCxvQkFBb0I3QixPQUFPLENBQUNqRCxDQUFBQTtnQkFDMUIsaURBQWlEO2dCQUNqRCxNQUFNOEQsWUFBWWlCLGlCQUFpQixDQUFDL0UsUUFBUSxJQUFJO2dCQUVoRCx3REFBd0Q7Z0JBQ3hELE1BQU1nRSxZQUNKaEUsWUFBWSxZQUFZLEtBQ3hCQSxZQUFZLGFBQWEsS0FDekJBLFlBQVksUUFBUSxLQUNwQkEsWUFBWSxXQUFXLEtBQ3ZCQSxZQUFZLFlBQVksS0FBSztnQkFFL0JnQyxVQUFVMEMsSUFBSSxDQUFDO29CQUNiMUUsU0FBU0E7b0JBQ1Q0QyxLQUFLO29CQUNMaUIsV0FBVztvQkFDWEosT0FBTztvQkFDUEUsYUFBYTtvQkFDYkcsV0FBV0E7b0JBQ1hFLFdBQVdBO2dCQUNiO1lBQ0Y7UUFDRjtRQUVBaEQsUUFBUUMsR0FBRyxDQUFDLENBQUMsWUFBWSxFQUFFZSxVQUFVekIsTUFBTSxDQUFDLFdBQVcsQ0FBQztJQUMxRCxFQUFFLE9BQU95RSxPQUFPO1FBQ2RoRSxRQUFRZ0UsS0FBSyxDQUFDLGdDQUFnQ0E7SUFDaEQ7SUFFQSxPQUFPaEQ7QUFDVDtBQUVBLGtDQUFrQztBQUNsQyxTQUFTMkMsZUFBZU0sS0FBYTtJQUNuQyxJQUFJLE9BQU9BLFVBQVUsWUFBWUMsTUFBTUQsUUFBUSxPQUFPO0lBRXRELElBQUlBLFNBQVMsS0FBSztRQUNoQixPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUNBLFFBQVEsR0FBRSxFQUFHRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDeEMsT0FBTyxJQUFJRixTQUFTLEtBQUs7UUFDdkIsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDQSxRQUFRLEdBQUUsRUFBR0UsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLE9BQU8sSUFBSUYsU0FBUyxLQUFLO1FBQ3ZCLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsUUFBUSxHQUFFLEVBQUdFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN4QyxPQUFPO1FBQ0wsT0FBTyxDQUFDLENBQUMsRUFBRUYsTUFBTUUsT0FBTyxDQUFDLEdBQUcsQ0FBQztJQUMvQjtBQUNGO0FBRUEsU0FBU1AsaUJBQWlCSyxLQUFhO0lBQ3JDLElBQUksT0FBT0EsVUFBVSxZQUFZQyxNQUFNRCxRQUFRLE9BQU87SUFDdEQsT0FBTyxDQUFDLEVBQUVBLFFBQVEsSUFBSSxNQUFNLEdBQUcsRUFBRUEsTUFBTUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3REO0FBRU8sZUFBZUMsa0JBQWtCNUYsS0FBYSxFQUFFbUMsSUFBUztJQUM5RFgsUUFBUUMsR0FBRyxDQUFDLHlDQUErQnpCO0lBQzNDd0IsUUFBUUMsR0FBRyxDQUFDLGlDQUF1QixJQUFJb0UsT0FBT0MsV0FBVztJQUV6RCxvQ0FBb0M7SUFDcEMsTUFBTUMsY0FBY2hHLGNBQWNDO0lBQ2xDLE1BQU1nRyxnQkFBZ0IxRixnQkFBZ0JOO0lBQ3RDLE1BQU0wQyxZQUFZaEMsaUJBQWlCVjtJQUNuQyxNQUFNNEMsY0FBYzVDLE1BQU1TLFdBQVcsR0FBR0osUUFBUSxDQUFDLGVBQWVMLE1BQU1TLFdBQVcsR0FBR0osUUFBUSxDQUFDO0lBQzdGLE1BQU00RixpQkFBaUIsQ0FBQ0YsWUFBWWhGLE1BQU0sSUFBSSxDQUFDaUYsY0FBY2pGLE1BQU07SUFFbkVTLFFBQVFDLEdBQUcsQ0FBQyw4QkFBb0JzRTtJQUNoQ3ZFLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBc0J1RTtJQUNsQ3hFLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJpQjtJQUM3QmxCLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBMkJtQjtJQUN2Q3BCLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBMEJ3RTtJQUV0QyxJQUFJO1FBQ0YsYUFBYTtRQUNiLE1BQU1DLFVBQVUsTUFBTXBHLGtEQUFZQSxDQUFDRTtRQUNuQ3dCLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBNEI7WUFDdENhLGlCQUFpQjRELFFBQVEzRCxVQUFVLEVBQUV4QixVQUFVO1lBQy9DcUIsbUJBQW1COEQsUUFBUTdELFlBQVksRUFBRXRCLFVBQVU7UUFDckQ7UUFFQSxvREFBb0Q7UUFDcEQsTUFBTW9GLFdBQVcsTUFBTUMsNkJBQTZCcEcsT0FBT2tHO1FBRTNELG1EQUFtRDtRQUNuRCxNQUFNRyxrQkFBa0I7WUFDdEI5RCxZQUFZMkQsUUFBUTNELFVBQVUsSUFBSSxFQUFFO1lBQ3BDRixjQUFjNkQsUUFBUTdELFlBQVksSUFBSSxFQUFFO1lBQ3hDaUUsaUJBQWlCSixRQUFRSSxlQUFlLElBQUksRUFBRTtZQUM5QzdCLFlBQVl5QixRQUFRekIsVUFBVSxJQUFJLEVBQUU7WUFDcEM4QixlQUFlTCxRQUFRSyxhQUFhLElBQUlDO1FBQzFDO1FBRUEsMEZBQTBGO1FBQzFGLE1BQU1DLGVBQWVDLHNCQUFzQjFHLE9BQU9xRyxpQkFBaUJGLFNBQVNRLFNBQVMsSUFBSSxFQUFFO1FBRTNGLE9BQU87WUFDTEMsU0FBU1QsU0FBU1MsT0FBTztZQUN6QnpFLE1BQU1rRTtZQUNOTSxXQUFXRjtZQUNYSSxTQUFTVixTQUFTVSxPQUFPO1lBQ3pCQyxXQUFXLElBQUlqQixPQUFPQyxXQUFXO1lBQ2pDaEUsVUFBVWlGLFFBQVFiLFFBQVE3RCxZQUFZLElBQUk2RCxRQUFRN0QsWUFBWSxDQUFDdEIsTUFBTSxHQUFHO1lBQ3hFZ0IsV0FBV2dGLFFBQVFaLFNBQVNRLFNBQVMsSUFBSVIsU0FBU1EsU0FBUyxDQUFDNUYsTUFBTSxHQUFHO1lBQ3JFa0IsZUFBZThFLFFBQVFiLFFBQVFLLGFBQWEsSUFBSVMsT0FBT0MsSUFBSSxDQUFDZixRQUFRSyxhQUFhLElBQUksQ0FBQyxHQUFHeEYsTUFBTSxHQUFHO1lBQ2xHaUIsZUFBZTtZQUNma0YsVUFBVWYsU0FBU2UsUUFBUSxJQUFJLEVBQUU7WUFDakNDLGFBQWFoQixTQUFTZ0IsV0FBVyxJQUFJLEVBQUU7WUFDdkNDLGNBQWNqQixTQUFTaUIsWUFBWSxJQUFJO1FBQ3pDO0lBRUYsRUFBRSxPQUFPNUIsT0FBTztRQUNkaEUsUUFBUWdFLEtBQUssQ0FBQyxpQ0FBaUNBO1FBRS9DLG1DQUFtQztRQUNuQyxPQUFPO1lBQ0xvQixTQUFTLENBQUMsb0JBQW9CLEVBQUVwQixpQkFBaUI2QixRQUFRN0IsTUFBTThCLE9BQU8sR0FBRyx5QkFBeUIsQ0FBQztZQUNuR25GLE1BQU0sQ0FBQztZQUNQMEUsU0FBUztnQkFBQzthQUFvQjtZQUM5QkMsV0FBVyxJQUFJakIsT0FBT0MsV0FBVztZQUNqQ2hFLFVBQVU7WUFDVkMsV0FBVztZQUNYRSxlQUFlO1lBQ2ZELGVBQWU7WUFDZmtGLFVBQVU7Z0JBQUM7YUFBdUM7WUFDbERDLGFBQWE7Z0JBQUM7YUFBZ0Q7WUFDOURDLGNBQWM7UUFDaEI7SUFDRjtBQUNGO0FBRUEsZUFBZWhCLDZCQUE2QnBHLEtBQWEsRUFBRW1DLElBQVMsRUFBRW9GLGFBQWEsQ0FBQztJQUNsRixJQUFLLElBQUlDLFVBQVUsR0FBR0EsV0FBV0QsWUFBWUMsVUFBVztRQUN0RCxJQUFJO1lBQ0ZoRyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxrQ0FBa0MsRUFBRStGLFFBQVEsQ0FBQyxFQUFFRCxXQUFXLElBQUksQ0FBQztZQUM1RSxNQUFNaEcsUUFBUVY7WUFDZFcsUUFBUUMsR0FBRyxDQUFDLENBQUMsYUFBYSxFQUFFRixNQUFNLGlCQUFpQixFQUFFaUcsVUFBVSxFQUFFLENBQUMsQ0FBQztZQUVuRSxNQUFNeEcsT0FBTyxJQUFJbkIsMENBQUlBLENBQUM7Z0JBQ3BCNEgsUUFBUUMsUUFBUUMsR0FBRyxDQUFDQyxZQUFZO1lBQ2xDO1lBQ0EseUVBQXlFO1lBQ3pFLDRFQUE0RTtZQUM1RSxNQUFNQyxVQUFVQyxtQkFBbUIzRixNQUFNbkMsT0FBT3dIO1lBQ2hELE1BQU1PLGNBQWNDLEtBQUtDLFNBQVMsQ0FBQ0osVUFBVSxpQ0FBaUM7WUFDOUUsTUFBTUssb0JBQW9CN0csS0FBSzhHLElBQUksQ0FBQ0osWUFBWWhILE1BQU0sR0FBRyxJQUFJLGtCQUFrQjtZQUMvRVMsUUFBUUMsR0FBRyxDQUFDLENBQUMseUJBQXlCLEVBQUVzRyxZQUFZaEgsTUFBTSxDQUFDLFNBQVMsRUFBRW1ILGtCQUFrQixRQUFRLENBQUM7WUFDakcsSUFBSUEsb0JBQW9CLE1BQU07Z0JBQzVCMUcsUUFBUTRHLElBQUksQ0FBQztnQkFDYiw0Q0FBNEM7Z0JBQzVDLE1BQU1DLFdBQVc7b0JBQ2ZDLE1BQU1ULFFBQVFTLElBQUk7b0JBQ2xCQyxZQUFZVixRQUFRVSxVQUFVO29CQUM5QkMsV0FBV1gsUUFBUXRGLFVBQVUsRUFBRWlCLE1BQU0sR0FBRztvQkFDeENpRixTQUFTWixRQUFReEYsWUFBWSxFQUFFbUIsTUFBTSxHQUFHO29CQUN4Q21CLE1BQU1rRCxRQUFRcEQsVUFBVSxFQUFFakIsTUFBTSxHQUFHLElBQUlrRixJQUFJLENBQUNDLElBQVk7NEJBQUVDLEdBQUdELEVBQUUvRCxLQUFLOzRCQUFFaUUsR0FBR0YsRUFBRUcsV0FBVzt3QkFBQztnQkFDekY7Z0JBQ0EsTUFBTUMsZUFBZWYsS0FBS0MsU0FBUyxDQUFDSTtnQkFDcEM3RyxRQUFRQyxHQUFHLENBQUMsQ0FBQyx3QkFBd0IsRUFBRXNILGFBQWFoSSxNQUFNLENBQUMsU0FBUyxFQUFFTSxLQUFLOEcsSUFBSSxDQUFDWSxhQUFhaEksTUFBTSxHQUFDLEdBQUcsUUFBUSxDQUFDO1lBQ2xIO1lBRUEsTUFBTWlJLGVBQWU7WUFDckIsTUFBTUMsYUFBYSxDQUFDLE9BQU8sRUFBRWpKLE1BQU0sT0FBTyxFQUFFK0gsWUFBWSwyT0FBMk8sQ0FBQztZQUVwUyxNQUFNbUIsYUFBYSxNQUFNbEksS0FBS21JLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxNQUFNLENBQUM7Z0JBQ3BEQyxVQUFVO29CQUNSO3dCQUFFQyxNQUFNO3dCQUFVQyxTQUFTUjtvQkFBYTtvQkFDeEM7d0JBQUVPLE1BQU07d0JBQVFDLFNBQVNQO29CQUFXO2lCQUNyQztnQkFDRDFIO2dCQUNBa0ksYUFBYTtnQkFDYkMsWUFBWTtnQkFDWkMsT0FBTztnQkFDUEMsUUFBUTtZQUNWO1lBRUEsTUFBTUMsV0FBV1gsV0FBV1ksT0FBTyxDQUFDLEVBQUUsRUFBRXhDLFNBQVNrQztZQUNqRCxJQUFJLENBQUNLLFVBQVU7Z0JBQ2IsTUFBTSxJQUFJeEMsTUFBTTtZQUNsQjtZQUVBLHNDQUFzQztZQUN0QyxJQUFJO2dCQUNGLE1BQU0wQyxZQUFZRixTQUFTRyxLQUFLLENBQUM7Z0JBQ2pDLElBQUlELFdBQVc7b0JBQ2IsT0FBTy9CLEtBQUtpQyxLQUFLLENBQUNGLFNBQVMsQ0FBQyxFQUFFO2dCQUNoQztZQUNGLEVBQUUsT0FBT0csWUFBWTtnQkFDbkIxSSxRQUFRNEcsSUFBSSxDQUFDO1lBQ2Y7WUFFQSxpREFBaUQ7WUFDakQsT0FBTztnQkFDTHhCLFNBQVNpRDtnQkFDVDNDLFVBQVU7b0JBQUM7aUJBQWtDO2dCQUM3Q0MsYUFBYTtvQkFBQztpQkFBNkI7Z0JBQzNDQyxjQUFjO2dCQUNkUCxTQUFTO29CQUFDO2lCQUFtQjtnQkFDN0JGLFdBQVcsRUFBRTtZQUNmO1FBRUYsRUFBRSxPQUFPbkIsT0FBWTtZQUNuQmhFLFFBQVFnRSxLQUFLLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRUEsTUFBTTJFLE1BQU0sS0FBSyxNQUFNLGVBQWUsZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFM0UsTUFBTTJFLE1BQU0sRUFBRTNFLE1BQU04QixPQUFPO1lBQ3ZILDRFQUE0RTtZQUM1RSxNQUFNOEMsTUFBYzVFLE9BQU84QixXQUFXO1lBQ3RDLElBQUk5QixNQUFNMkUsTUFBTSxLQUFLLE9BQU9DLElBQUkvSixRQUFRLENBQUMsd0JBQXdCK0osSUFBSS9KLFFBQVEsQ0FBQyxzQkFBdUI7Z0JBQ25HbUIsUUFBUTRHLElBQUksQ0FBQztnQkFDYnRIO2dCQUNBLElBQUkwRyxVQUFVRCxZQUFZO29CQUN4QixNQUFNLElBQUk4QyxRQUFRQyxDQUFBQSxJQUFLQyxXQUFXRCxHQUFHLE1BQU05QztvQkFDM0M7Z0JBQ0Y7WUFDRjtZQUVBLElBQUloQyxNQUFNMkUsTUFBTSxLQUFLLEtBQUs7Z0JBQ3hCM0ksUUFBUUMsR0FBRyxDQUFDO2dCQUNaWDtnQkFDQSxJQUFJMEcsVUFBVUQsWUFBWTtvQkFDeEIsTUFBTWlELFFBQVFuSixLQUFLQyxHQUFHLENBQUMsT0FBT0QsS0FBS29KLEdBQUcsQ0FBQyxHQUFHakQsVUFBVTtvQkFDcERoRyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxZQUFZLEVBQUUrSSxNQUFNLHlCQUF5QixDQUFDO29CQUMzRCxNQUFNLElBQUlILFFBQVFLLENBQUFBLFVBQVdILFdBQVdHLFNBQVNGO29CQUNqRDtnQkFDRjtZQUNGLE9BQU8sSUFBSWhGLE1BQU0yRSxNQUFNLEtBQUssS0FBSztnQkFDL0IzSSxRQUFRQyxHQUFHLENBQUM7Z0JBQ1pYO2dCQUNBLElBQUkwRyxVQUFVRCxZQUFZO29CQUN4QixNQUFNaUQsUUFBUSxPQUFPaEQ7b0JBQ3JCaEcsUUFBUUMsR0FBRyxDQUFDLENBQUMsWUFBWSxFQUFFK0ksTUFBTSx5QkFBeUIsQ0FBQztvQkFDM0QsTUFBTSxJQUFJSCxRQUFRSyxDQUFBQSxVQUFXSCxXQUFXRyxTQUFTRjtvQkFDakQ7Z0JBQ0Y7WUFDRjtZQUVBLE1BQU1oRjtRQUNSO0lBQ0Y7SUFFQSxNQUFNLElBQUk2QixNQUFNO0FBQ2xCO0FBRUEsK0RBQStEO0FBQy9ELFNBQVNTLG1CQUFtQjNGLElBQVMsRUFBRW5DLEtBQWEsRUFBRXdILE9BQWU7SUFDbkUsSUFBSTtRQUNGLE1BQU1tRCxTQUFTLENBQUMzSyxTQUFTLEVBQUMsRUFBR1MsV0FBVztRQUN4QyxNQUFNc0YsY0FBY2hHLGNBQWNDLFNBQVM7UUFDM0MsTUFBTTRLLFVBQVVwRCxZQUFZLElBQUksS0FBS0EsWUFBWSxJQUFJLEtBQUs7UUFDMUQsTUFBTXFELFlBQVlyRCxZQUFZLElBQUksS0FBS0EsWUFBWSxJQUFJLElBQUk7UUFDM0QsTUFBTXNELFVBQVV0RCxZQUFZLElBQUksS0FBS0EsWUFBWSxJQUFJLEtBQUs7UUFFMUQsTUFBTWpGLGFBQWEsQ0FBQ0osS0FBS0ksVUFBVSxJQUFJLEVBQUUsRUFDdENyQyxNQUFNLENBQUMsQ0FBQzRELElBQVdpQyxZQUFZaEYsTUFBTSxHQUFHZ0YsWUFBWTFGLFFBQVEsQ0FBQ3lELEVBQUVGLE1BQU0sSUFBSSxNQUN6RVgsSUFBSSxDQUFDLENBQUNDLEdBQVFDLElBQVcsQ0FBQ0EsRUFBRTRILFNBQVMsSUFBSSxLQUFNN0gsQ0FBQUEsRUFBRTZILFNBQVMsSUFBSSxJQUM5RHZILEtBQUssQ0FBQyxHQUFHcUgsV0FDVG5DLEdBQUcsQ0FBQyxDQUFDNUUsSUFBWTtnQkFDaEJGLFFBQVFFLEVBQUVGLE1BQU07Z0JBQ2hCRixNQUFNSSxFQUFFSixJQUFJO2dCQUNaTyxPQUFPSCxFQUFFRyxLQUFLO2dCQUNkRyxnQkFBZ0JOLEVBQUVNLGNBQWM7Z0JBQ2hDMkcsV0FBV2pILEVBQUVpSCxTQUFTO2dCQUN0QkMsV0FBV2xILEVBQUVrSCxTQUFTO1lBQ3hCO1FBRUYsTUFBTTNJLGVBQWUsQ0FBQ0YsS0FBS0UsWUFBWSxJQUFJLEVBQUUsRUFDMUNZLElBQUksQ0FBQyxDQUFDQyxHQUFRQyxJQUFXLENBQUNBLEVBQUVDLEdBQUcsSUFBSSxLQUFNRixDQUFBQSxFQUFFRSxHQUFHLElBQUksSUFDbERJLEtBQUssQ0FBQyxHQUFHb0gsU0FDVGxDLEdBQUcsQ0FBQyxDQUFDdUMsSUFBWTtnQkFDaEJ2SCxNQUFNdUgsRUFBRXZILElBQUk7Z0JBQ1pOLEtBQUs2SCxFQUFFN0gsR0FBRztnQkFDVkUsY0FBYzJILEVBQUUzSCxZQUFZO2dCQUM1QkQsYUFBYTRILEVBQUU1SCxXQUFXO2dCQUMxQjZILFFBQVFELEVBQUVDLE1BQU0sRUFBRTFILE1BQU0sR0FBRztZQUM3QjtRQUVGLE1BQU1pQixhQUFhLENBQUN0QyxLQUFLc0MsVUFBVSxJQUFJLEVBQUUsRUFDdENqQixLQUFLLENBQUMsR0FBR3NILFNBQ1RwQyxHQUFHLENBQUMsQ0FBQ0MsSUFBWTtnQkFBRS9ELE9BQU8rRCxFQUFFL0QsS0FBSztnQkFBRU4sV0FBV3FFLEVBQUVyRSxTQUFTO2dCQUFFd0UsYUFBYUgsRUFBRUcsV0FBVztZQUFDO1FBRXpGLE1BQU1xQyxlQUFlaEosS0FBS29FLGFBQWEsRUFBRTZFLFdBQVc7WUFDbERDLFdBQVdsSixLQUFLb0UsYUFBYSxDQUFDNkUsUUFBUSxDQUFDQyxTQUFTO1lBQ2hEQyxjQUFjbkosS0FBS29FLGFBQWEsQ0FBQzZFLFFBQVEsQ0FBQ0UsWUFBWTtZQUN0REMsTUFBTXBKLEtBQUtvRSxhQUFhLENBQUM2RSxRQUFRLENBQUNHLElBQUk7UUFDeEMsSUFBSS9FO1FBRUosbURBQW1EO1FBQ25ELE1BQU1nRixXQUFXLENBQUNySixLQUFLRSxZQUFZLElBQUksRUFBRSxFQUFFb0osTUFBTSxDQUFDLENBQUNDLEdBQVdULElBQVdTLElBQUtULENBQUFBLEVBQUU3SCxHQUFHLElBQUksSUFBSTtRQUMzRixNQUFNdUksaUJBQWlCcEosV0FBV3hCLE1BQU0sR0FBSXdCLFdBQVdrSixNQUFNLENBQUMsQ0FBQ0MsR0FBVzVILElBQVc0SCxJQUFLNUgsQ0FBQUEsRUFBRU0sY0FBYyxJQUFJLElBQUksS0FBSzdCLFdBQVd4QixNQUFNLEdBQUk7UUFFNUksTUFBTTZLLGlCQUFpQjFKLDZCQUE2QjtZQUNsREc7WUFDQUU7WUFDQWtDO1FBQ0YsR0FBR3pFLE9BQU93RCxLQUFLLENBQUMsR0FBRyxLQUFLLHFCQUFxQjtRQUU3QyxPQUFPO1lBQ0w4RSxNQUFNO2dCQUNKZDtnQkFDQXpCO2dCQUNBOEYsZUFBZTdMLE1BQU13RCxLQUFLLENBQUMsR0FBRztZQUNoQztZQUNBK0UsWUFBWTtnQkFDVmlEO2dCQUNBRyxnQkFBZ0JHLE9BQU9ILGVBQWVoRyxPQUFPLENBQUM7Z0JBQzlDb0csV0FBVyxDQUFDNUosS0FBS0UsWUFBWSxJQUFJLEVBQUUsRUFBRXRCLE1BQU07Z0JBQzNDaUwsYUFBYSxDQUFDN0osS0FBS0ksVUFBVSxJQUFJLEVBQUUsRUFBRXhCLE1BQU07Z0JBQzNDeUQsV0FBVyxDQUFDckMsS0FBS3NDLFVBQVUsSUFBSSxFQUFFLEVBQUUxRCxNQUFNO1lBQzNDO1lBQ0F3QjtZQUNBRjtZQUNBb0M7WUFDQXdILFdBQVdkO1lBQ1gsMkRBQTJEO1lBQzNEZSxnQkFBZ0JOO1FBQ2xCO0lBQ0YsRUFBRSxPQUFPTyxHQUFHO1FBQ1YzSyxRQUFRNEcsSUFBSSxDQUFDLDBEQUEwRCtEO1FBQ3ZFLE9BQU87WUFBRTdELE1BQU07Z0JBQUVkO2dCQUFTaEMsT0FBTztZQUFLO1lBQUdqRCxZQUFZLEVBQUU7WUFBRUYsY0FBYyxFQUFFO1FBQUM7SUFDNUU7QUFDRjtBQUVBLG9FQUFvRTtBQUNwRSxTQUFTK0osd0JBQXdCakssSUFBUyxFQUFFbkMsS0FBYTtJQUN2RCxJQUFJNEcsVUFBVTtJQUVkLElBQUk7UUFDRiw0REFBNEQ7UUFDNUQsTUFBTXlGLGFBQWFyTSxNQUFNUyxXQUFXO1FBQ3BDLE1BQU02TCxrQkFBa0JELFdBQVdoTSxRQUFRLENBQUMsY0FBY2dNLFdBQVdoTSxRQUFRLENBQUM7UUFDOUUsTUFBTWtNLG1CQUFtQkYsV0FBV2hNLFFBQVEsQ0FBQyxlQUFlZ00sV0FBV2hNLFFBQVEsQ0FBQztRQUNoRixNQUFNbU0sZUFBZUgsV0FBV2hNLFFBQVEsQ0FBQyxXQUFXZ00sV0FBV2hNLFFBQVEsQ0FBQyxlQUFlZ00sV0FBV2hNLFFBQVEsQ0FBQztRQUMzRyxNQUFNb00sZ0JBQWdCSixXQUFXaE0sUUFBUSxDQUFDLFlBQVlnTSxXQUFXaE0sUUFBUSxDQUFDLGFBQWFnTSxXQUFXaE0sUUFBUSxDQUFDO1FBQzNHLE1BQU1xTSxjQUFjTCxXQUFXaE0sUUFBUSxDQUFDLFVBQVVnTSxXQUFXaE0sUUFBUSxDQUFDLFdBQVdnTSxXQUFXaE0sUUFBUSxDQUFDO1FBRXJHLDRDQUE0QztRQUM1Q3VHLFdBQVcsQ0FBQywwQkFBMEIsRUFBRTRGLGVBQWUsbUJBQ2pCRixrQkFBa0IsWUFDbEJDLG1CQUFtQixhQUNuQixvQkFBb0IsMEJBQTBCLENBQUM7UUFFckYsNkJBQTZCO1FBQzdCLElBQUlwSyxLQUFLRSxZQUFZLElBQUlTLE1BQU1DLE9BQU8sQ0FBQ1osS0FBS0UsWUFBWSxLQUFLRixLQUFLRSxZQUFZLENBQUN0QixNQUFNLEdBQUcsR0FBRztZQUN6RixNQUFNNEwsY0FBY3hLLEtBQUtFLFlBQVksQ0FBQ21CLEtBQUssQ0FBQyxHQUFHO1lBQy9Db0QsV0FBVyxDQUFDLG9DQUFvQyxFQUFFekUsS0FBS0UsWUFBWSxDQUFDdEIsTUFBTSxDQUFDLG1CQUFtQixDQUFDO1lBRS9GLElBQUkyTCxlQUFlLENBQUNELGVBQWU7Z0JBQ2pDN0YsV0FBVyxDQUFDLHVEQUF1RCxFQUFFK0YsWUFBWWpFLEdBQUcsQ0FBQyxDQUFDdUMsSUFBV0EsR0FBR3ZILFFBQVEsV0FBV2tKLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUN2STtZQUVBLE1BQU1DLFdBQVcxSyxLQUFLRSxZQUFZLENBQUNvSixNQUFNLENBQUMsQ0FBQ3FCLEtBQWE3QixJQUFXNkIsTUFBTzdCLENBQUFBLEdBQUc3SCxPQUFPLElBQUk7WUFDeEYsSUFBSXlKLFdBQVcsR0FBRztnQkFDaEJqRyxXQUFXLENBQUMsMERBQTBELEVBQUUsQ0FBQ2lHLFdBQVcsR0FBRSxFQUFHbEgsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQzFHO1lBRUEsK0NBQStDO1lBQy9DLE1BQU1vSCx3QkFBd0I1SyxLQUFLRSxZQUFZLENBQUNuQyxNQUFNLENBQUMsQ0FBQytLLElBQ3RELE9BQU9BLEVBQUU1SCxXQUFXLEtBQUssWUFBWSxPQUFPNEgsRUFBRTNILFlBQVksS0FBSztZQUdqRSxJQUFJeUosc0JBQXNCaE0sTUFBTSxHQUFHLEdBQUc7Z0JBQ3BDLHFCQUFxQjtnQkFDckIsTUFBTWlNLGlCQUFpQjt1QkFBSUQ7aUJBQXNCLENBQUM5SixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFDeEQsQ0FBQ0EsRUFBRUUsV0FBVyxJQUFJRixFQUFFRyxZQUFZLElBQUksS0FBTUosQ0FBQUEsRUFBRUcsV0FBVyxJQUFJSCxFQUFFSSxZQUFZLElBQUk7Z0JBR2hGLE1BQU0ySixZQUFZRCxjQUFjLENBQUMsRUFBRTtnQkFDbkMsTUFBTUUsV0FBV0YsY0FBYyxDQUFDQSxlQUFlak0sTUFBTSxHQUFHLEVBQUU7Z0JBRTFELElBQUlrTSxhQUFjQSxDQUFBQSxVQUFVNUosV0FBVyxHQUFHLEtBQUs0SixVQUFVM0osWUFBWSxHQUFHLElBQUk7b0JBQzFFLE1BQU02SixjQUFjRixVQUFVNUosV0FBVyxJQUFJNEosVUFBVTNKLFlBQVk7b0JBQ25Fc0QsV0FBVyxDQUFDLEVBQUVxRyxVQUFVdkosSUFBSSxDQUFDLGlDQUFpQyxFQUFFeUosWUFBWXhILE9BQU8sQ0FBQyxHQUFHLG1CQUFtQixDQUFDO2dCQUM3RztnQkFFQSxJQUFJdUgsWUFBYUEsQ0FBQUEsU0FBUzdKLFdBQVcsR0FBRyxLQUFLNkosU0FBUzVKLFlBQVksR0FBRyxJQUFJO29CQUN2RSxNQUFNNkosY0FBY0QsU0FBUzdKLFdBQVcsSUFBSTZKLFNBQVM1SixZQUFZO29CQUNqRXNELFdBQVcsQ0FBQyxFQUFFc0csU0FBU3hKLElBQUksQ0FBQyxtQkFBbUIsRUFBRXJDLEtBQUs0RCxHQUFHLENBQUNrSSxhQUFheEgsT0FBTyxDQUFDLEdBQUcsbUJBQW1CLENBQUM7Z0JBQ3hHO1lBQ0Y7UUFDRjtRQUVBLHlCQUF5QjtRQUN6QixJQUFJeEQsS0FBS0ksVUFBVSxJQUFJTyxNQUFNQyxPQUFPLENBQUNaLEtBQUtJLFVBQVUsS0FBS0osS0FBS0ksVUFBVSxDQUFDeEIsTUFBTSxHQUFHLEdBQUc7WUFDbkYsK0JBQStCO1lBQy9CLE1BQU1xTSxNQUFNLElBQUl2SDtZQUNoQixNQUFNd0gsVUFBVUQsSUFBSUUsa0JBQWtCLENBQUMsU0FBUztnQkFDOUNDLE9BQU87Z0JBQ1BDLEtBQUs7Z0JBQ0xDLE1BQU07WUFDUjtZQUVBN0csV0FBVyxDQUFDLFFBQVEsRUFBRXlHLFFBQVEsRUFBRSxDQUFDO1lBRWpDLE1BQU1LLE1BQU12TCxLQUFLSSxVQUFVLENBQUNzQixJQUFJLENBQUMsQ0FBQ0MsSUFBV0EsR0FBR0YsV0FBVztZQUMzRCxNQUFNK0osTUFBTXhMLEtBQUtJLFVBQVUsQ0FBQ3NCLElBQUksQ0FBQyxDQUFDQyxJQUFXQSxHQUFHRixXQUFXO1lBRTNELElBQUk4SixPQUFPLE9BQU9BLElBQUl6SixLQUFLLEtBQUssVUFBVTtnQkFDeEMyQyxXQUFXLENBQUMsaUNBQWlDLEVBQUU4RyxJQUFJekosS0FBSyxDQUFDMkosY0FBYyxDQUFDcEgsV0FBVztvQkFBQ3FILHVCQUF1QjtnQkFBQyxHQUFHLENBQUM7Z0JBQ2hILElBQUksT0FBT0gsSUFBSXRKLGNBQWMsS0FBSyxVQUFVO29CQUMxQ3dDLFdBQVcsQ0FBQyxzQkFBc0IsRUFBRThHLElBQUl0SixjQUFjLEdBQUcsSUFBSSxNQUFNLEdBQUcsRUFBRXNKLElBQUl0SixjQUFjLENBQUN1QixPQUFPLENBQUMsR0FBRyxHQUFHLENBQUM7Z0JBQzVHLE9BQU87b0JBQ0xpQixXQUFXO2dCQUNiO1lBQ0Y7WUFFQSxJQUFJK0csT0FBTyxPQUFPQSxJQUFJMUosS0FBSyxLQUFLLFVBQVU7Z0JBQ3hDMkMsV0FBVyxDQUFDLHdCQUF3QixFQUFFK0csSUFBSTFKLEtBQUssQ0FBQzJKLGNBQWMsQ0FBQ3BILFdBQVc7b0JBQUNxSCx1QkFBdUI7Z0JBQUMsR0FBRyxDQUFDO2dCQUN2RyxJQUFJLE9BQU9GLElBQUl2SixjQUFjLEtBQUssVUFBVTtvQkFDMUN3QyxXQUFXLENBQUMsc0JBQXNCLEVBQUUrRyxJQUFJdkosY0FBYyxHQUFHLElBQUksTUFBTSxHQUFHLEVBQUV1SixJQUFJdkosY0FBYyxDQUFDdUIsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUM1RyxPQUFPO29CQUNMaUIsV0FBVztnQkFDYjtZQUNGO1lBRUEsaURBQWlEO1lBQ2pELE1BQU1rSCxlQUFlM0wsS0FBS0ksVUFBVSxDQUFDckMsTUFBTSxDQUFDLENBQUM0RCxJQUMzQ0EsR0FBR0YsV0FBVyxTQUFTRSxHQUFHRixXQUFXLFNBQVMsT0FBT0UsR0FBR0csVUFBVSxZQUFZLE9BQU9ILEdBQUdNLG1CQUFtQjtZQUc3RyxJQUFJMEosYUFBYS9NLE1BQU0sR0FBRyxHQUFHO2dCQUMzQixzREFBc0Q7Z0JBQ3RELE1BQU1pTSxpQkFBaUI7dUJBQUljO2lCQUFhLENBQUM3SyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRWlCLGNBQWMsR0FBR2xCLEVBQUVrQixjQUFjO2dCQUUzRiw0QkFBNEI7Z0JBQzVCLE1BQU02SSxZQUFZRCxjQUFjLENBQUMsRUFBRTtnQkFDbkMsTUFBTUUsV0FBV0YsY0FBYyxDQUFDQSxlQUFlak0sTUFBTSxHQUFHLEVBQUU7Z0JBRTFENkYsV0FBVyxDQUFDLG9CQUFvQixDQUFDO2dCQUVqQyxJQUFJcUcsYUFBYUEsVUFBVTdJLGNBQWMsR0FBRyxHQUFHO29CQUM3Q3dDLFdBQVcsQ0FBQyxFQUFFcUcsVUFBVXZKLElBQUksQ0FBQyxFQUFFLEVBQUV1SixVQUFVckosTUFBTSxDQUFDLDhCQUE4QixFQUFFcUosVUFBVTdJLGNBQWMsR0FBRyxJQUFJLE1BQU0sR0FBRyxFQUFFNkksVUFBVTdJLGNBQWMsQ0FBQ3VCLE9BQU8sQ0FBQyxHQUFHLDhCQUE4QixFQUFFc0gsVUFBVWhKLEtBQUssQ0FBQzJKLGNBQWMsQ0FBQ3BILFdBQVc7d0JBQUNxSCx1QkFBdUI7b0JBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQzNRO2dCQUVBLElBQUlYLFlBQVlBLFNBQVM5SSxjQUFjLEdBQUcsR0FBRztvQkFDM0N3QyxXQUFXLENBQUMsRUFBRXNHLFNBQVN4SixJQUFJLENBQUMsRUFBRSxFQUFFd0osU0FBU3RKLE1BQU0sQ0FBQywrQkFBK0IsRUFBRXNKLFNBQVM5SSxjQUFjLENBQUN1QixPQUFPLENBQUMsR0FBRyxlQUFlLEVBQUV1SCxTQUFTakosS0FBSyxDQUFDMkosY0FBYyxDQUFDcEgsV0FBVzt3QkFBQ3FILHVCQUF1QjtvQkFBQyxHQUFHLEVBQUUsQ0FBQztnQkFDL007WUFDRjtRQUNGO1FBRUEscUNBQXFDO1FBQ3JDakgsV0FBVyxDQUFDLGdCQUFnQixFQUFFbUgsMEJBQTBCL04sT0FBT21DLE1BQU0sQ0FBQztJQUV4RSxFQUFFLE9BQU9xRCxPQUFPO1FBQ2RoRSxRQUFRZ0UsS0FBSyxDQUFDLHFDQUFxQ0E7UUFDbkRvQixVQUFVO0lBQ1o7SUFFQSxPQUFPQSxXQUFXO0FBQ3BCO0FBRUEsNERBQTREO0FBQzVELFNBQVNtSCwwQkFBMEIvTixLQUFhLEVBQUVtQyxJQUFTO0lBQ3pELE1BQU1rSyxhQUFhck0sTUFBTVMsV0FBVztJQUNwQyxJQUFJdU4sYUFBYTtJQUVqQix1Q0FBdUM7SUFDdkMsSUFBSUMsa0JBQWtCO0lBQ3RCLElBQUlDLGtCQUFrQjtJQUV0QixnQ0FBZ0M7SUFDaEMsSUFBSS9MLEtBQUtJLFVBQVUsSUFBSU8sTUFBTUMsT0FBTyxDQUFDWixLQUFLSSxVQUFVLEdBQUc7UUFDckRKLEtBQUtJLFVBQVUsQ0FBQ2tCLE9BQU8sQ0FBQyxDQUFDNEI7WUFDdkIsSUFBSUEsUUFBUWpCLGlCQUFpQixHQUFHNko7aUJBQzNCLElBQUk1SSxRQUFRakIsaUJBQWlCLEdBQUc4SjtRQUN2QztJQUNGO0lBRUEsOEJBQThCO0lBQzlCLElBQUkvTCxLQUFLRSxZQUFZLElBQUlTLE1BQU1DLE9BQU8sQ0FBQ1osS0FBS0UsWUFBWSxHQUFHO1FBQ3pERixLQUFLRSxZQUFZLENBQUNvQixPQUFPLENBQUMsQ0FBQ2pEO1lBQ3pCLE1BQU0yTixTQUFTM04sU0FBUzhDLGdCQUFnQjlDLFNBQVM2QztZQUNqRCxJQUFJOEssU0FBUyxHQUFHRjtpQkFDWCxJQUFJRSxTQUFTLEdBQUdEO1FBQ3ZCO0lBQ0Y7SUFFQSxNQUFNRSxrQkFBa0JILGtCQUFrQkMsa0JBQWtCLGFBQ3BDQSxrQkFBa0JELGtCQUFrQixhQUFhO0lBRXpFLDBDQUEwQztJQUMxQyxJQUFJNUIsV0FBV2hNLFFBQVEsQ0FBQyxhQUFhZ00sV0FBV2hNLFFBQVEsQ0FBQyxRQUFRO1FBQy9ELE9BQVErTjtZQUNOLEtBQUs7Z0JBQ0hKLGFBQWE7Z0JBQ2I7WUFDRixLQUFLO2dCQUNIQSxhQUFhO2dCQUNiO1lBQ0Y7Z0JBQ0VBLGFBQWE7UUFDakI7SUFDRixPQUFPLElBQUkzQixXQUFXaE0sUUFBUSxDQUFDLFlBQVlnTSxXQUFXaE0sUUFBUSxDQUFDLGFBQWE7UUFDMUUsT0FBUStOO1lBQ04sS0FBSztnQkFDSEosYUFBYTtnQkFDYjtZQUNGLEtBQUs7Z0JBQ0hBLGFBQWE7Z0JBQ2I7WUFDRjtnQkFDRUEsYUFBYTtRQUNqQjtJQUNGLE9BQU87UUFDTCxPQUFRSTtZQUNOLEtBQUs7Z0JBQ0hKLGFBQWE7Z0JBQ2I7WUFDRixLQUFLO2dCQUNIQSxhQUFhO2dCQUNiO1lBQ0Y7Z0JBQ0VBLGFBQWE7UUFDakI7SUFDRjtJQUVBLE9BQU9BO0FBQ1Q7QUFFQSwwR0FBMEc7QUFDMUcsU0FBU3RILHNCQUFzQjFHLEtBQWEsRUFBRXFPLE9BQVksRUFBRUMsUUFBd0I7SUFDbEYsSUFBSTtRQUNGLE1BQU0zTSxJQUFJM0IsTUFBTVMsV0FBVztRQUMzQixJQUFJLENBQUMsb0JBQW9Cb0IsSUFBSSxDQUFDRixJQUFJLE9BQU8yTSxVQUFVLGtDQUFrQztRQUVyRiwyREFBMkQ7UUFDM0QsTUFBTXJPLFNBQVNGLGNBQWNDLFFBQVEsNEJBQTRCO1FBQ2pFLE1BQU11TyxjQUFjdE8sT0FBT3lJLEdBQUcsQ0FBQ0UsQ0FBQUEsSUFBS0EsRUFBRW5JLFdBQVc7UUFFakQsbURBQW1EO1FBQ25ELE1BQU0rTixlQUF3QztZQUM1QyxPQUFPO2dCQUFDO2FBQVc7WUFDbkIsT0FBTztnQkFBQzthQUFVO1lBQ2xCLE9BQU87Z0JBQUM7YUFBUztZQUNqQixPQUFPO2dCQUFDO2dCQUFPO2FBQVU7WUFDekIsT0FBTztnQkFBQzthQUFVO1FBQ3BCO1FBQ0F2TyxPQUFPd0QsT0FBTyxDQUFDZ0wsQ0FBQUE7WUFDWkQsQ0FBQUEsWUFBWSxDQUFDQyxJQUFJLElBQUksRUFBRSxFQUFFaEwsT0FBTyxDQUFDa0YsQ0FBQUEsSUFBSzRGLFlBQVlySixJQUFJLENBQUN5RDtRQUMxRDtRQUVBLHlFQUF5RTtRQUN6RSxJQUFJMUksT0FBT2MsTUFBTSxJQUFJLEtBQUtkLE9BQU9jLE1BQU0sSUFBSSxHQUFHO1lBQzVDLE1BQU0yTixXQUFXSixTQUFTcE8sTUFBTSxDQUFDb0ssQ0FBQUE7Z0JBQy9CLE1BQU1xRSxPQUFPckUsRUFBRTlKLE9BQU8sRUFBRUM7Z0JBQ3hCLE9BQU84TixZQUFZSyxJQUFJLENBQUNoRyxDQUFBQSxJQUFLK0YsS0FBS3RPLFFBQVEsQ0FBQ3VJO1lBQzdDO1lBRUEsMEdBQTBHO1lBQzFHLElBQUk4RixTQUFTM04sTUFBTSxLQUFLLEdBQUc7Z0JBQ3pCLE1BQU04TixVQUEwQixFQUFFO2dCQUNqQ1IsQ0FBQUEsUUFBUTlMLFVBQVUsSUFBSSxFQUFFLEVBQUVrQixPQUFPLENBQUMsQ0FBQ0s7b0JBQ2xDLElBQUk3RCxPQUFPSSxRQUFRLENBQUN5RCxFQUFFRixNQUFNLEdBQUc7d0JBQzdCaUwsUUFBUTNKLElBQUksQ0FBQzs0QkFDWDFFLFNBQVNzRCxFQUFFSixJQUFJOzRCQUNmTixLQUFLOzRCQUNMaUIsV0FBVzs0QkFDWEosT0FBTyxPQUFPSCxFQUFFRyxLQUFLLEtBQUssV0FBVyxDQUFDLENBQUMsRUFBRUgsRUFBRUcsS0FBSyxDQUFDMEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHOzRCQUNoRXhCLGFBQWEsT0FBT0wsRUFBRU0sY0FBYyxLQUFLLFdBQVcsQ0FBQyxFQUFFTixFQUFFTSxjQUFjLEdBQUMsSUFBRSxNQUFJLEdBQUcsRUFBRU4sRUFBRU0sY0FBYyxDQUFDdUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUc7NEJBQ3BIckIsV0FBV1IsRUFBRU0sY0FBYyxHQUFHLElBQUksYUFBYU4sRUFBRU0sY0FBYyxHQUFHLENBQUMsSUFBSSxhQUFhOzRCQUNwRkksV0FBV1YsRUFBRUYsTUFBTSxLQUFLLFFBQVEsS0FBS0UsRUFBRUYsTUFBTSxLQUFLLFFBQVEsS0FBSzt3QkFDakU7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsT0FBT2lMLFFBQVFyTCxLQUFLLENBQUMsR0FBR3ZELE9BQU9jLE1BQU07WUFDdkM7WUFFQSw2RUFBNkU7WUFDN0UsTUFBTStOLFFBQVFQO1lBQ2RHLFNBQVN6TCxJQUFJLENBQUMsQ0FBQ0MsR0FBRUMsSUFBTTJMLE1BQU1DLFNBQVMsQ0FBQ25HLENBQUFBLElBQUsxRixFQUFFMUMsT0FBTyxDQUFDQyxXQUFXLEdBQUdKLFFBQVEsQ0FBQ3VJLE1BQU1rRyxNQUFNQyxTQUFTLENBQUNuRyxDQUFBQSxJQUFLekYsRUFBRTNDLE9BQU8sQ0FBQ0MsV0FBVyxHQUFHSixRQUFRLENBQUN1STtZQUN6SSxPQUFPOEYsU0FBU2xMLEtBQUssQ0FBQyxHQUFHdkQsT0FBT2MsTUFBTTtRQUN4QztRQUNBLE9BQU91TjtJQUNULEVBQUUsT0FBT25DLEdBQUc7UUFDVjNLLFFBQVE0RyxJQUFJLENBQUMsMERBQTBEK0Q7UUFDdkUsT0FBT21DO0lBQ1Q7QUFDRjtBQUVPLGVBQWVVLGlCQUFpQmhQLEtBQWEsRUFBRW1DLElBQVM7SUFDN0QsSUFBSTtRQUNGLE1BQU04TSxTQUFTLENBQUM7cUVBQ2lELEVBQUVqUCxNQUFNOztNQUV2RSxFQUFFZ0ksS0FBS0MsU0FBUyxDQUFDOUYsTUFBTSxNQUFNLEdBQUc7Ozs7Ozs7QUFPdEMsQ0FBQztRQUVHLElBQUloQixhQUFhO1FBQ2pCLE1BQU1vRyxhQUFhO1FBQ25CLElBQUkySCxhQUFhLE1BQU0sNEJBQTRCO1FBRW5ELE1BQU8vTixjQUFjb0csV0FBWTtZQUMvQixJQUFJO2dCQUNGLE1BQU0yQixhQUFhLE1BQU1sSSxLQUFLbUksSUFBSSxDQUFDQyxXQUFXLENBQUNDLE1BQU0sQ0FBQztvQkFDcERDLFVBQVU7d0JBQ1I7NEJBQ0VDLE1BQU07NEJBQ05DLFNBQVM7d0JBQ1g7d0JBQ0E7NEJBQ0VELE1BQU07NEJBQ05DLFNBQVN5Rjt3QkFDWDtxQkFDRDtvQkFDRDFOLE9BQU9MLGdCQUFnQkM7b0JBQ3ZCc0ksYUFBYTtvQkFDYkMsWUFBWTtnQkFDZDtnQkFFQSxPQUFPUixXQUFXWSxPQUFPLENBQUMsRUFBRSxFQUFFeEMsU0FBU2tDLFdBQVc7WUFDcEQsRUFBRSxPQUFPMkYsWUFBWTtnQkFDbkIsTUFBTUMsZUFBZUQsc0JBQXNCOUgsUUFBUThILFdBQVc3SCxPQUFPLEdBQUc7Z0JBQ3hFLE1BQU0rSCxrQkFBa0JELGFBQWEvTyxRQUFRLENBQUM7Z0JBQzlDLE1BQU1pUCxtQkFBbUJGLGFBQWEvTyxRQUFRLENBQUMsMEJBQTBCK08sYUFBYS9PLFFBQVEsQ0FBQztnQkFFL0ZtQixRQUFRZ0UsS0FBSyxDQUFDLENBQUMsZ0JBQWdCLEVBQUU4SixtQkFBbUIsZUFBZ0JELGtCQUFrQixtQkFBbUIsZ0JBQWlCLFlBQVksRUFBRWxPLGFBQWEsRUFBRSxDQUFDLEVBQUVvRyxhQUFhLEVBQUUsQ0FBQyxDQUFDLEVBQUU0SDtnQkFFN0ssSUFBSWhPLGNBQWNvRyxZQUFZO29CQUM1QixNQUFNNEgsWUFBWSxzQ0FBc0M7Z0JBQzFEO2dCQUVBLG9EQUFvRDtnQkFDcERELGNBQWM7Z0JBQ2QxTixRQUFRQyxHQUFHLENBQUMsQ0FBQyxZQUFZLEVBQUV5TixXQUFXLHlCQUF5QixDQUFDO2dCQUNoRSxNQUFNLElBQUk3RSxRQUFRSyxDQUFBQSxVQUFXSCxXQUFXRyxTQUFTd0U7Z0JBQ2pEL047WUFDRjtRQUNGO1FBRUEseUVBQXlFO1FBQ3pFLE9BQU87SUFDVCxFQUFFLE9BQU9xRSxPQUFPO1FBQ2RoRSxRQUFRZ0UsS0FBSyxDQUFDLDhCQUE4QkE7UUFFNUMsK0VBQStFO1FBQy9FLElBQUksT0FBZ0I4QixTQUFTakgsU0FBUyxvQkFBb0IsT0FBZ0I4SixXQUFXLEtBQUs7WUFDeEYzSSxRQUFRQyxHQUFHLENBQUM7WUFDWmlHLFFBQVFDLEdBQUcsQ0FBQzRILGFBQWEsR0FBRztRQUM5QjtRQUVBLDhEQUE4RDtRQUM5RCxNQUFNbEQsYUFBYXJNLE1BQU1TLFdBQVc7UUFFcEMsSUFBSTRMLFdBQVdoTSxRQUFRLENBQUMsYUFBYWdNLFdBQVdoTSxRQUFRLENBQUMsUUFBUTtZQUMvRCxPQUFPO1FBQ1QsT0FBTyxJQUFJZ00sV0FBV2hNLFFBQVEsQ0FBQyxZQUFZZ00sV0FBV2hNLFFBQVEsQ0FBQyxXQUFXO1lBQ3hFLE9BQU87UUFDVCxPQUFPO1lBQ0wsT0FBTztRQUNUO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyeXB0by1yZXNlYXJjaC1hc3Npc3RhbnQvLi9saWIvZ3JvcS50cz8zM2RkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdyb3EgfSBmcm9tICdncm9xLXNkayc7XHJcbmltcG9ydCB7IFJlc2VhcmNoUmVzdWx0LCBEYXRhVGFibGVSb3cgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgZmV0Y2hBbGxEYXRhIH0gZnJvbSAnLi9hcGknO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgZGF0YSBleHRyYWN0aW9uXHJcbmZ1bmN0aW9uIGV4dHJhY3RUb2tlbnMocXVlcnk6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICBjb25zdCB0b2tlbnMgPSBbJ0JUQycsICdFVEgnLCAnVVNEVCcsICdVU0RDJywgJ0JOQicsICdTT0wnLCAnQURBJywgJ0RPVCcsICdBVkFYJywgJ01BVElDJ107XHJcbiAgcmV0dXJuIHRva2Vucy5maWx0ZXIodG9rZW4gPT4gcXVlcnkudG9VcHBlckNhc2UoKS5pbmNsdWRlcyh0b2tlbikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHRyYWN0UHJvamVjdHMocXVlcnk6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICBjb25zdCBwcm9qZWN0cyA9IFsnVW5pc3dhcCcsICdBYXZlJywgJ0NvbXBvdW5kJywgJ01ha2VyJywgJ0N1cnZlJywgJ1N1c2hpJywgJ1BhbmNha2VTd2FwJ107XHJcbiAgcmV0dXJuIHByb2plY3RzLmZpbHRlcihwcm9qZWN0ID0+IHF1ZXJ5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocHJvamVjdC50b0xvd2VyQ2FzZSgpKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RUaW1lRnJhbWUocXVlcnk6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKHF1ZXJ5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2RheScpIHx8IHF1ZXJ5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJzI0aCcpKSByZXR1cm4gJ2RheSc7XHJcbiAgaWYgKHF1ZXJ5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3dlZWsnKSB8fCBxdWVyeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCc3ZCcpKSByZXR1cm4gJ3dlZWsnO1xyXG4gIGlmIChxdWVyeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdtb250aCcpIHx8IHF1ZXJ5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJzMwZCcpKSByZXR1cm4gJ21vbnRoJztcclxuICByZXR1cm4gJ3dlZWsnO1xyXG59XHJcblxyXG4vLyBHcm9xIEFQSSBjb25maWd1cmF0aW9uIHdpdGggZmFsbGJhY2sgbW9kZWxzXHJcbmNvbnN0IEdST1FfTU9ERUxTID0gW1xyXG4gICdsbGFtYS0zLjEtOGItaW5zdGFudCcsICAgIC8vIEZhc3QsIHJlbGlhYmxlXHJcbiAgJ2xsYW1hLTMuMS03MGItdmVyc2F0aWxlJywgLy8gSGlnaCBxdWFsaXR5XHJcbiAgJ21peHRyYWwtOHg3Yi0zMjc2OCcsICAgICAgLy8gR29vZCBiYWxhbmNlXHJcbiAgJ2dlbW1hMi05Yi1pdCcgICAgICAgICAgICAgLy8gRmFsbGJhY2tcclxuXTtcclxuXHJcbmxldCBjdXJyZW50TW9kZWxJbmRleCA9IDA7XHJcblxyXG5jb25zdCBnZXRHcm9xTW9kZWwgPSAoKSA9PiB7XHJcbiAgcmV0dXJuIEdST1FfTU9ERUxTW2N1cnJlbnRNb2RlbEluZGV4XSB8fCBHUk9RX01PREVMU1swXTtcclxufTtcclxuXHJcbmNvbnN0IG5leHRNb2RlbCA9ICgpID0+IHtcclxuICBjdXJyZW50TW9kZWxJbmRleCA9IChjdXJyZW50TW9kZWxJbmRleCArIDEpICUgR1JPUV9NT0RFTFMubGVuZ3RoO1xyXG4gIHJldHVybiBnZXRHcm9xTW9kZWwoKTtcclxufTtcclxuXHJcbi8vIEluaXRpYWxpemUgd2l0aG91dCBleHBsaWNpdGx5IHNldHRpbmcgdGhlIEFQSSBrZXksIGl0IHdpbGwgdXNlIEdST1FfQVBJX0tFWSBlbnYgdmFyIGF1dG9tYXRpY2FsbHlcclxuY29uc3QgZ3JvcSA9IG5ldyBHcm9xKCk7XHJcblxyXG4vLyBBdmFpbGFibGUgbW9kZWwgZmFsbGJhY2tzIGluIG9yZGVyIG9mIHByZWZlcmVuY2VcclxuY29uc3QgTU9ERUxfRkFMTEJBQ0tTID0gW1xyXG4gICdsbGFtYS0zLjMtNzBiLXZlcnNhdGlsZScsICAvLyBQcmltYXJ5IG1vZGVsXHJcbiAgJ2xsYW1hLTMuMi03MGItdmVyc2F0aWxlJywgIC8vIEZhbGxiYWNrIDFcclxuICAnZ2VtbWEtN2ItaXQnLCAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgMlxyXG4gICdtaXN0cmFsLTdiLWluc3RydWN0JywgICAgICAvLyBGYWxsYmFjayAzXHJcbiAgJ21peHRyYWwtOHg3Yi0zMjc2OCcgICAgICAgIC8vIEZhbGxiYWNrIDRcclxuXTtcclxuXHJcbi8vIEZ1bmN0aW9uIHRvIHNlbGVjdCB0aGUgYXBwcm9wcmlhdGUgbW9kZWwgYmFzZWQgb24gcmV0cnkgY291bnRcclxuZnVuY3Rpb24gZ2V0Q3VycmVudE1vZGVsKHJldHJ5Q291bnQ6IG51bWJlciA9IDApOiBzdHJpbmcge1xyXG4gIC8vIElmIHJldHJ5Q291bnQgaXMgYmV5b25kIG91ciBhdmFpbGFibGUgbW9kZWxzLCB1c2UgdGhlIGxhc3Qgb25lXHJcbiAgY29uc3QgaW5kZXggPSBNYXRoLm1pbihyZXRyeUNvdW50LCBNT0RFTF9GQUxMQkFDS1MubGVuZ3RoIC0gMSk7XHJcbiAgY29uc3QgbW9kZWwgPSBNT0RFTF9GQUxMQkFDS1NbaW5kZXhdO1xyXG4gIGNvbnNvbGUubG9nKGBVc2luZyBtb2RlbDogJHttb2RlbH0gKHJldHJ5IGF0dGVtcHQ6ICR7cmV0cnlDb3VudH0pYCk7XHJcbiAgcmV0dXJuIG1vZGVsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXRlY3RJbnRlbnRzKHF1ZXJ5OiBzdHJpbmcpIHtcclxuICBjb25zdCBxID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcclxuICBcclxuICAvLyBDaGVjayBpZiBxdWVyeSBpcyBjcnlwdG8tcmVsYXRlZFxyXG4gIGNvbnN0IGlzQ3J5cHRvUmVsYXRlZCA9IC9jcnlwdG98Yml0Y29pbnxldGhlcmV1bXxkZWZpfGJsb2NrY2hhaW58dG9rZW58Y29pbnxtYXJrZXR8cHJpY2V8dHZsfHByb3RvY29sfHRyYWRpbmd8d2FsbGV0fGV4Y2hhbmdlfG5mdHx3ZWIzfG1ldGF2ZXJzZXxkYW98eWllbGR8c3Rha2luZ3xsaXF1aWRpdHl8c3dhcHxhbW18ZGV4fGNleHxhbHRjb2lufG1lbWV8c3RhYmxlY29pbnxnb3Zlcm5hbmNlfHZhbGlkYXRvcnxtaW5pbmd8aGFzaHxnYXN8ZmVlfHNsaXBwYWdlfGltcGVybWFuZW50fGxvc3N8YXB5fGFwcnx2b2x1bWV8bWFya2V0Y2FwfGNhcHxyYW5rfGNoYXJ0fHRlY2huaWNhbHxmdW5kYW1lbnRhbHxhbmFseXNpc3x0cmVuZHxidWxsfGJlYXJ8cHVtcHxkdW1wfGhvZGx8Zm9tb3xmdWR8c2hpbGx8bW9vbnxsYW1ib3xyZWt0fHNlcnxhbm9ufGdtfHdhZ21pfG5nbWl8ZGlhbW9uZHxoYW5kc3xwYXBlcnxoYW5kc3xkY2F8YnRjfGV0aHx1c2R0fHVzZGN8ZGFpfGxpbmt8dW5pfGFhdmV8Y29tcHxta3J8c3VzaGl8Y3VydmV8YmFsYW5jZXJ8eWVhcm58aGFydmVzdHxwaWNrbGV8Y3JlYW18YWxwaGF8YmV0YXxnYW1tYXxkZWx0YXx0aGV0YXx2ZWdhfHJob3xncmVla3N8b3B0aW9uc3xmdXR1cmVzfHBlcnBldHVhbHxsZXZlcmFnZXxtYXJnaW58c2hvcnR8bG9uZ3xoZWRnZXxhcmJpdHJhZ2V8ZnJvbnRydW58c2FuZHdpY2h8bWV2fGZsYXNofGxvYW58Y29sbGF0ZXJhbHxkZWJ0fGNlaWxpbmd8Zmxvb3J8cmVzaXN0YW5jZXxzdXBwb3J0fGZpYm9uYWNjaXxyc2l8bWFjZHxib2xsaW5nZXJ8bW92aW5nfGF2ZXJhZ2V8ZW1hfHNtYXxlbWF8dm9sdW1lfHByb2ZpbGV8b3JkZXJ8Ym9va3xiaWR8YXNrfHNwcmVhZHxkZXB0aHxsaXF1aWRpdHl8cG9vbHxwYWlyfHJvdXRlfHNsaXBwYWdlfGltcGFjdHxwcmljZXxpbXBhY3R8Y3VydmV8Ym9uZGluZ3xjdXJ2ZXxhbW18YXV0b21hdGVkfG1hcmtldHxtYWtlcnxjb25zdGFudHxwcm9kdWN0fGNvbnN0YW50fHN1bXxjb25zdGFudHxtZWFufGdlb21ldHJpY3xtZWFufGhhcm1vbmljfG1lYW58d2VpZ2h0ZWR8YXZlcmFnZXxwcmljZXx2d2FwfHR3YXB8b3JhY2xlfGNoYWlubGlua3xiYW5kfG5lc3R8cHl0aHx1bWJyZWxsYXxhcGkzfGRpYXx0ZWxsb3J8cHJvdmFibGV8cmFuZG9tfG51bWJlcnxnZW5lcmF0b3J8dnJmfHZlcmlmaWFibGV8cmFuZG9tfGZ1bmN0aW9ufGNvbW1pdHxyZXZlYWx8c2NoZW1lfHplcm98a25vd2xlZGdlfHByb29mfHprcHxzbmFya3xzdGFya3xwbG9ua3xncm90aHxidWxsZXRwcm9vZnxyYW5nZXxwcm9vZnxyaW5nfHNpZ25hdHVyZXxjb25maWRlbnRpYWx8dHJhbnNhY3Rpb258bWltYmxld2ltYmxlfGdyaW58YmVhbXxtb25lcm98cHJpdmFjeXxjb2lufG1peGVyfHR1bWJsZXJ8Y29pbmpvaW58d2FzYWJpfHNhbW91cmFpfGpvaW5tYXJrZXR8YXRvbWljfHN3YXB8Y3Jvc3N8Y2hhaW58YnJpZGdlfHdvcm1ob2xlfG11bHRpY2hhaW58YW55c3dhcHxzdGFyZ2F0ZXxsYXllcnx6ZXJvfGNvc21vc3xwb2xrYWRvdHxhdmFsYW5jaGV8cG9seWdvbnxhcmJpdHJ1bXxvcHRpbWlzbXxiYXNlfHprc3luY3xzY3JvbGx8bGluZWF8bWFudGxlfG9wfHN0YWNrfHJvbGx1cHx6a3xyb2xsdXB8b3B0aW1pc3RpY3xyb2xsdXB8dmFsaWRpdW18cGxhc21hfHN0YXRlfGNoYW5uZWx8cGF5bWVudHxjaGFubmVsfGxpZ2h0bmluZ3xuZXR3b3JrfGxpcXVpZHxzaWRlY2hhaW58cGVnfGlufHBlZ3xvdXR8d3JhcHBlZHx0b2tlbnx3YnRjfHdldGh8d21hdGljfHdhdmF4fHdibmJ8d2Z0bXx3b25lfHdtb3ZyfHdnbG1yfHdrc218d2RvdHx3YXRvbXx3b3Ntb3x3anVufHdzY3J0fHdiYW5kfHdsaW5rfHd1bml8d2FhdmV8d2NvbXB8d21rcnx3c3VzaGl8d2N1cnZlfHdiYWxhbmNlcnx3eWVhcm58d2hhcnZlc3R8d3BpY2tsZXx3Y3JlYW18d2FscGhhfHdiZXRhfHdnYW1tYXx3ZGVsdGF8d3RoZXRhfHd2ZWdhfHdyaG98d2dyZWVrc3x3b3B0aW9uc3x3ZnV0dXJlc3x3cGVycGV0dWFsfHdsZXZlcmFnZXx3bWFyZ2lufHdzaG9ydHx3bG9uZ3x3aGVkZ2V8d2FyYml0cmFnZXx3ZnJvbnRydW58d3NhbmR3aWNofHdtZXZ8d2ZsYXNofHdsb2FufHdjb2xsYXRlcmFsfHdkZWJ0fHdjZWlsaW5nfHdmbG9vcnx3cmVzaXN0YW5jZXx3c3VwcG9ydHx3Zmlib25hY2NpfHdyc2l8d21hY2R8d2JvbGxpbmdlcnx3bW92aW5nfHdhdmVyYWdlfHdlbWF8d3NtYXx3ZW1hfHd2b2x1bWV8d3Byb2ZpbGV8d29yZGVyfHdib29rfHdiaWR8d2Fza3x3c3ByZWFkfHdkZXB0aHx3bGlxdWlkaXR5fHdwb29sfHdwYWlyfHdyb3V0ZXx3c2xpcHBhZ2V8d2ltcGFjdHx3cHJpY2V8d2ltcGFjdHx3Y3VydmV8d2JvbmRpbmd8d2N1cnZlfHdhbW18d2F1dG9tYXRlZHx3bWFya2V0fHdtYWtlcnx3Y29uc3RhbnR8d3Byb2R1Y3R8d2NvbnN0YW50fHdzdW18d2NvbnN0YW50fHdtZWFufHdnZW9tZXRyaWN8d21lYW58d2hhcm1vbmljfHdtZWFufHd3ZWlnaHRlZHx3YXZlcmFnZXx3cHJpY2V8d3Z3YXB8d3R3YXB8d29yYWNsZXx3Y2hhaW5saW5rfHdiYW5kfHduZXN0fHdweXRofHd1bWJyZWxsYXx3YXBpM3x3ZGlhfHd0ZWxsb3J8d3Byb3ZhYmxlfHdyYW5kb218d251bWJlcnx3Z2VuZXJhdG9yfHd2cmZ8d3ZlcmlmaWFibGV8d3JhbmRvbXx3ZnVuY3Rpb258d2NvbW1pdHx3cmV2ZWFsfHdzY2hlbWV8d3plcm98d2tub3dsZWRnZXx3cHJvb2Z8d3prcHx3c25hcmt8d3N0YXJrfHdwbG9ua3x3Z3JvdGh8d2J1bGxldHByb29mfHdyYW5nZXx3cHJvb2Z8d3Jpbmd8d3NpZ25hdHVyZXx3Y29uZmlkZW50aWFsfHd0cmFuc2FjdGlvbnx3bWltYmxld2ltYmxlfHdncmlufHdiZWFtfHdtb25lcm98d3ByaXZhY3l8d2NvaW58d21peGVyfHd0dW1ibGVyfHdjb2luam9pbnx3d2FzYWJpfHdzYW1vdXJhaXx3am9pbm1hcmtldHx3YXRvbWljfHdzd2FwfHdjcm9zc3x3Y2hhaW58d2JyaWRnZXx3d29ybWhvbGV8d211bHRpY2hhaW58d2FueXN3YXB8d3N0YXJnYXRlfHdsYXllcnx3emVyb3x3Y29zbW9zfHdwb2xrYWRvdHx3YXZhbGFuY2hlfHdwb2x5Z29ufHdhcmJpdHJ1bXx3b3B0aW1pc218d2Jhc2V8d3prc3luY3x3c2Nyb2xsfHdsaW5lYXx3bWFudGxlfHdvcHx3c3RhY2t8d3JvbGx1cHx3emt8d3JvbGx1cHx3b3B0aW1pc3RpY3x3cm9sbHVwfHd2YWxpZGl1bXx3cGxhc21hfHdzdGF0ZXx3Y2hhbm5lbHx3cGF5bWVudHx3Y2hhbm5lbHx3bGlnaHRuaW5nfHduZXR3b3JrfHdsaXF1aWR8d3NpZGVjaGFpbnx3cGVnfHdpbnx3cGVnfHdvdXR8d3dyYXBwZWR8d3Rva2VuLy50ZXN0KHEpO1xyXG4gIFxyXG4gIC8vIElmIG5vdCBjcnlwdG8tcmVsYXRlZCwgcmV0dXJuIGFsbCBmYWxzZVxyXG4gIGlmICghaXNDcnlwdG9SZWxhdGVkKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzaG93RGVGaTogZmFsc2UsXHJcbiAgICAgIHNob3dUYWJsZTogZmFsc2UsXHJcbiAgICAgIGlzQ3J5cHRvUXVlcnk6IGZhbHNlXHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgc2hvd0RlRmk6IC9kZWZpfHByb3RvY29sfHR2bHxwcm9qZWN0fGNvbXBhcmV8dG9wfHBlcmZvcm1hbmNlfGdyb3d0aC8udGVzdChxKSxcclxuICAgIHNob3dUYWJsZTogL2NvbXBhcmV8dGFibGV8bGlzdHx0b3B8cGVyZm9ybWFuY2V8c3VtbWFyeXxtZXRyaWNzLy50ZXN0KHEpLFxyXG4gICAgc2hvd0V0aGVyc2NhbjogL2V0aGVyZXVtfGV0aHxjb250cmFjdHx0cmFuc2FjdGlvbnxnYXN8YmxvY2tjaGFpbnxhZGRyZXNzfHRva2VufHNtYXJ0IGNvbnRyYWN0Ly50ZXN0KHEpLFxyXG4gICAgaXNDcnlwdG9RdWVyeTogdHJ1ZVxyXG4gIH07XHJcbn1cclxuXHJcbi8vIEdlbmVyYXRlIGRhdGEgdGFibGUgZnJvbSByYXcgZGF0YSBzb3VyY2VzIHRoYXQncyByZWxldmFudCB0byB0aGUgcXVlcnlcclxuZnVuY3Rpb24gZ2VuZXJhdGVEYXRhVGFibGVGcm9tUmF3RGF0YShkYXRhOiBhbnksIHF1ZXJ5OiBzdHJpbmcgPSAnJyk6IERhdGFUYWJsZVJvd1tdIHtcclxuICBjb25zb2xlLmxvZygn8J+UhCBHZW5lcmF0aW5nIGRhdGEgdGFibGUgZnJvbSByYXcgZGF0YSBmb3IgcXVlcnk6JywgcXVlcnkpO1xyXG4gIGNvbnNvbGUubG9nKCfwn5OKIElucHV0IGRhdGEgc3RydWN0dXJlOicsIHtcclxuICAgIGRlZmlQcm9qZWN0c0NvdW50OiBkYXRhLmRlZmlQcm9qZWN0cz8ubGVuZ3RoIHx8IDAsXHJcbiAgICBjcnlwdG9EYXRhQ291bnQ6IGRhdGEuY3J5cHRvRGF0YT8ubGVuZ3RoIHx8IDBcclxuICB9KTtcclxuXHJcbiAgY29uc3QgdGFibGVSb3dzOiBEYXRhVGFibGVSb3dbXSA9IFtdO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICAvLyBFeHRyYWN0IHF1ZXJ5IGNvbnRleHQgaWYgYXZhaWxhYmxlXHJcbiAgICBjb25zdCBxdWVyeUNvbnRleHQgPSBkYXRhLnF1ZXJ5Q29udGV4dCB8fCB7XHJcbiAgICAgIHRpbWVGcmFtZTogJ3dlZWsnLFxyXG4gICAgICB0b3BOOiA1LFxyXG4gICAgICB1c2VUcmVuZGluZzogZmFsc2VcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBhIGJldHRlciBtYXBwaW5nIGJldHdlZW4gRGVGaSBwcm9qZWN0cyBhbmQgdGhlaXIgdG9rZW5zXHJcbiAgICBjb25zdCBwcm9qZWN0VG9rZW5NYXBwaW5nOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xyXG4gICAgICAnVW5pc3dhcCc6ICdVTkknLFxyXG4gICAgICAnQWF2ZSc6ICdBQVZFJywgXHJcbiAgICAgICdDb21wb3VuZCc6ICdDT01QJyxcclxuICAgICAgJ01ha2VyREFPJzogJ01LUicsXHJcbiAgICAgICdMaWRvJzogJ0xETycsXHJcbiAgICAgICdDdXJ2ZSc6ICdDUlYnLFxyXG4gICAgICAnU3VzaGlTd2FwJzogJ1NVU0hJJyxcclxuICAgICAgJ1llYXJuIEZpbmFuY2UnOiAnWUZJJyxcclxuICAgICAgJ1N5bnRoZXRpeCc6ICdTTlgnLFxyXG4gICAgICAnUGFuY2FrZVN3YXAnOiAnQ0FLRScsXHJcbiAgICAgICdCYWxhbmNlcic6ICdCQUwnLFxyXG4gICAgICAnMWluY2gnOiAnMUlOQ0gnXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIElmIHdlIGhhdmUgRGVGaSBwcm9qZWN0cywgdXNlIHRoZW0gYXMgdGhlIHByaW1hcnkgZGF0YSBzb3VyY2VcclxuICAgIGlmIChkYXRhLmRlZmlQcm9qZWN0cyAmJiBBcnJheS5pc0FycmF5KGRhdGEuZGVmaVByb2plY3RzKSkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+Pm++4jyBQcm9jZXNzaW5nIERlRmkgcHJvamVjdHMgZGF0YScpO1xyXG4gICAgICBcclxuICAgICAgLy8gU29ydCBwcm9qZWN0cyBiYXNlZCBvbiBxdWVyeSBjb250ZXh0XHJcbiAgICAgIGxldCBzb3J0ZWRQcm9qZWN0cyA9IFsuLi5kYXRhLmRlZmlQcm9qZWN0c107XHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiBxdWVyeSBtZW50aW9ucyBUVkwgb3IgZ3Jvd3RoLCBzb3J0IGJ5IFRWTFxyXG4gICAgICBpZiAocXVlcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndHZsJykgfHwgcXVlcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZ3Jvd3RoJykgfHwgcXVlcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnc3VyZ2UnKSkge1xyXG4gICAgICAgIGlmIChxdWVyeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdoaWdoZXN0JykgfHwgcXVlcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndG9wJykgfHwgcXVlcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYmVzdCcpKSB7XHJcbiAgICAgICAgICAvLyBTb3J0IGJ5IFRWTCBkZXNjZW5kaW5nXHJcbiAgICAgICAgICBzb3J0ZWRQcm9qZWN0cy5zb3J0KChhLCBiKSA9PiAoYi50dmwgfHwgMCkgLSAoYS50dmwgfHwgMCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocXVlcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnY2hhbmdlJykgfHwgcXVlcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZ3Jvd3RoJykgfHwgcXVlcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnc3VyZ2UnKSkge1xyXG4gICAgICAgICAgLy8gU29ydCBieSBUVkwgY2hhbmdlXHJcbiAgICAgICAgICBzb3J0ZWRQcm9qZWN0cy5zb3J0KChhLCBiKSA9PiBcclxuICAgICAgICAgICAgKChiLnR2bENoYW5nZTdkIHx8IGIudHZsQ2hhbmdlMjRoIHx8IDApIC0gKGEudHZsQ2hhbmdlN2QgfHwgYS50dmxDaGFuZ2UyNGggfHwgMCkpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gTGltaXQgdG8gYSByZWFzb25hYmxlIG51bWJlciBvZiByb3dzIGJhc2VkIG9uIHRoZSBxdWVyeVxyXG4gICAgICBjb25zdCBsaW1pdCA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3RvcCAxMCcpID8gMTAgOiBcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd0b3AgNScpID8gNSA6IFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDEwLCBxdWVyeUNvbnRleHQudG9wTiB8fCA1KTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgc29ydGVkUHJvamVjdHMuc2xpY2UoMCwgbGltaXQpLmZvckVhY2goKHByb2plY3Q6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGlmIChwcm9qZWN0ICYmIHByb2plY3QubmFtZSkge1xyXG4gICAgICAgICAgICAvLyBGaW5kIGNvcnJlc3BvbmRpbmcgY3J5cHRvIHByaWNlIGRhdGEgdXNpbmcgYmV0dGVyIG1hdGNoaW5nXHJcbiAgICAgICAgICBjb25zdCB0b2tlblN5bWJvbCA9IHByb2plY3RUb2tlbk1hcHBpbmdbcHJvamVjdC5uYW1lXSB8fCBwcm9qZWN0LnN5bWJvbDtcclxuICAgICAgICAgIGNvbnN0IGNyeXB0b0RhdGEgPSBkYXRhLmNyeXB0b0RhdGE/LmZpbmQoKGM6IGFueSkgPT4gXHJcbiAgICAgICAgICAgIGM/LnN5bWJvbD8udG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5TeW1ib2w/LnRvTG93ZXJDYXNlKCkgfHxcclxuICAgICAgICAgICAgYz8uc3ltYm9sPy50b0xvd2VyQ2FzZSgpID09PSBwcm9qZWN0LnN5bWJvbD8udG9Mb3dlckNhc2UoKSB8fFxyXG4gICAgICAgICAgICBjPy5uYW1lPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHByb2plY3QubmFtZS50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICBwcm9qZWN0Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhjPy5uYW1lPy50b0xvd2VyQ2FzZSgpKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGluZGV4IDwgMykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBQcm9qZWN0ICR7cHJvamVjdC5uYW1lfTpgLCB7XHJcbiAgICAgICAgICAgICAgdG9rZW5TeW1ib2wsXHJcbiAgICAgICAgICAgICAgZm91bmRDcnlwdG86ICEhY3J5cHRvRGF0YSxcclxuICAgICAgICAgICAgICBjcnlwdG9QcmljZTogY3J5cHRvRGF0YT8ucHJpY2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENyZWF0ZSBhIHByZWRpY3RhYmxlIG1hcHBpbmcgb2YgRGVGaSBwcm9qZWN0cyB0byBzZW50aW1lbnRzXHJcbiAgICAgICAgICBjb25zdCBkZWZpUHJvamVjdFNlbnRpbWVudHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XHJcbiAgICAgICAgICAgICdVbmlzd2FwJzogJ1Bvc2l0aXZlJyxcclxuICAgICAgICAgICAgJ0FhdmUnOiAnUG9zaXRpdmUnLFxyXG4gICAgICAgICAgICAnQ29tcG91bmQnOiAnTmV1dHJhbCcsXHJcbiAgICAgICAgICAgICdNYWtlckRBTyc6ICdQb3NpdGl2ZScsXHJcbiAgICAgICAgICAgICdDdXJ2ZSc6ICdOZXV0cmFsJyxcclxuICAgICAgICAgICAgJ0xpZG8nOiAnUG9zaXRpdmUnLFxyXG4gICAgICAgICAgICAnU3VzaGlTd2FwJzogJ05ldXRyYWwnLFxyXG4gICAgICAgICAgICAnWWVhcm4gRmluYW5jZSc6ICdOZXV0cmFsJyxcclxuICAgICAgICAgICAgJ1N5bnRoZXRpeCc6ICdQb3NpdGl2ZScsXHJcbiAgICAgICAgICAgICdQYW5jYWtlU3dhcCc6ICdQb3NpdGl2ZScsXHJcbiAgICAgICAgICAgICdCYWxhbmNlcic6ICdOZXV0cmFsJyxcclxuICAgICAgICAgICAgJzFpbmNoJzogJ05ldXRyYWwnXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBFeHRyYWN0IGNoYW5nZSB2YWx1ZXNcclxuICAgICAgICAgIGNvbnN0IHByaWNlQ2hhbmdlID0gY3J5cHRvRGF0YT8ucHJpY2VDaGFuZ2UyNGggfHwgMDtcclxuICAgICAgICAgIGNvbnN0IHR2bENoYW5nZSA9IHByb2plY3QudHZsQ2hhbmdlN2QgfHwgcHJvamVjdC50dmxDaGFuZ2UyNGggfHwgMDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVXNlIHRoZSBwcmVkZWZpbmVkIHNlbnRpbWVudCBvciBjYWxjdWxhdGUgYmFzZWQgb24gbWV0cmljc1xyXG4gICAgICAgICAgbGV0IHNlbnRpbWVudCA9IGRlZmlQcm9qZWN0U2VudGltZW50c1twcm9qZWN0Lm5hbWVdIHx8ICdOZXV0cmFsJztcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gT25seSB1c2UgY2FsY3VsYXRpb25zIGZvciBwcm9qZWN0cyBub3QgaW4gb3VyIG1hcHBpbmdcclxuICAgICAgICAgIGlmICghZGVmaVByb2plY3RTZW50aW1lbnRzW3Byb2plY3QubmFtZV0pIHtcclxuICAgICAgICAgICAgLy8gSWYgYm90aCBtZXRyaWNzIGFyZSBhdmFpbGFibGUsIHVzZSB0aGVtIGJvdGhcclxuICAgICAgICAgICAgaWYgKGNyeXB0b0RhdGEgJiYgKHByaWNlQ2hhbmdlICE9PSAwIHx8IHR2bENoYW5nZSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgICAvLyBXZWlnaHQgcHJpY2UgY2hhbmdlcyBtb3JlIGhlYXZpbHkgdGhhbiBUVkxcclxuICAgICAgICAgICAgICBjb25zdCBjb21iaW5lZENoYW5nZSA9IGNyeXB0b0RhdGEgPyAocHJpY2VDaGFuZ2UgKiAwLjcgKyB0dmxDaGFuZ2UgKiAwLjMpIDogdHZsQ2hhbmdlO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGlmIChjb21iaW5lZENoYW5nZSA+IDIuNSkgc2VudGltZW50ID0gJ1Bvc2l0aXZlJztcclxuICAgICAgICAgICAgICBlbHNlIGlmIChjb21iaW5lZENoYW5nZSA8IC0yLjUpIHNlbnRpbWVudCA9ICdOZWdhdGl2ZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG5ld3MgY291bnQgYmFzZWQgb24gYWN0dWFsIG5ld3MgZXZlbnRzIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgbGV0IG5ld3NDb3VudDogbnVtYmVyO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIG5ld3MgZXZlbnRzIGRhdGFcclxuICAgICAgICAgIGlmIChkYXRhLm5ld3NFdmVudHMgJiYgQXJyYXkuaXNBcnJheShkYXRhLm5ld3NFdmVudHMpICYmIGRhdGEubmV3c0V2ZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIENvdW50IG5ld3MgZXZlbnRzIHJlbGF0ZWQgdG8gdGhpcyBwcm9qZWN0XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3ROZXdzID0gZGF0YS5uZXdzRXZlbnRzLmZpbHRlcigobmV3czogYW55KSA9PiBcclxuICAgICAgICAgICAgICBuZXdzLnRpdGxlLmluY2x1ZGVzKHByb2plY3QubmFtZSkgfHwgXHJcbiAgICAgICAgICAgICAgKHByb2plY3Quc3ltYm9sICYmIG5ld3MudGl0bGUuaW5jbHVkZXMocHJvamVjdC5zeW1ib2wpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBuZXdzQ291bnQgPSBwcm9qZWN0TmV3cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiBubyBuZXdzIHdhcyBmb3VuZCwgdXNlIGEgc21hbGwgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAobmV3c0NvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbmV3c0NvdW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNSkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBnZW5lcmF0ZSBhIHJlYWxpc3RpYyBuZXdzIGNvdW50IGJhc2VkIG9uIHRoZSBwcm9qZWN0IHBvcHVsYXJpdHlcclxuICAgICAgICAgICAgY29uc3QgYmFzZU5ld3NDb3VudCA9IE1hdGguZmxvb3IoNSArIChwcm9qZWN0LnR2bCB8fCAwKSAvIDFlOSk7ICAvLyBNb3JlIFRWTCA9IG1vcmUgbmV3c1xyXG4gICAgICAgICAgICBuZXdzQ291bnQgPSBNYXRoLm1pbigzMCwgTWF0aC5tYXgoNSwgXHJcbiAgICAgICAgICAgICAgYmFzZU5ld3NDb3VudCArIChNYXRoLmFicyh0dmxDaGFuZ2UpID4gNSA/IDEwIDogMCkgIC8vIEJpZyBUVkwgY2hhbmdlcyBnZW5lcmF0ZSBtb3JlIG5ld3NcclxuICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHRhYmxlUm93cy5wdXNoKHtcclxuICAgICAgICAgICAgcHJvamVjdDogcHJvamVjdC5uYW1lLFxyXG4gICAgICAgICAgICB0dmw6IGZvcm1hdEN1cnJlbmN5KHByb2plY3QudHZsIHx8IDApLFxyXG4gICAgICAgICAgICB0dmxDaGFuZ2U6IGZvcm1hdFBlcmNlbnRhZ2UodHZsQ2hhbmdlKSxcclxuICAgICAgICAgICAgcHJpY2U6IGNyeXB0b0RhdGEgPyBmb3JtYXRDdXJyZW5jeShjcnlwdG9EYXRhLnByaWNlIHx8IDApIDogJ04vQScsXHJcbiAgICAgICAgICAgIHByaWNlQ2hhbmdlOiBjcnlwdG9EYXRhID8gZm9ybWF0UGVyY2VudGFnZShwcmljZUNoYW5nZSkgOiAnTi9BJyxcclxuICAgICAgICAgICAgc2VudGltZW50OiBzZW50aW1lbnQsXHJcbiAgICAgICAgICAgIG5ld3NDb3VudDogbmV3c0NvdW50XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBJZiBubyBEZUZpIHByb2plY3RzIGJ1dCB3ZSBoYXZlIGNyeXB0byBkYXRhLCB1c2UgY3J5cHRvIGRhdGFcclxuICAgIGlmICh0YWJsZVJvd3MubGVuZ3RoID09PSAwICYmIGRhdGEuY3J5cHRvRGF0YSAmJiBBcnJheS5pc0FycmF5KGRhdGEuY3J5cHRvRGF0YSkpIHtcclxuICAgICAgY29uc29sZS5sb2coJ/CfkrAgRmFsbGluZyBiYWNrIHRvIGNyeXB0byBkYXRhJyk7XHJcbiAgICAgIGRhdGEuY3J5cHRvRGF0YS5zbGljZSgwLCAxMCkuZm9yRWFjaCgoY3J5cHRvOiBhbnkpID0+IHtcclxuICAgICAgICBpZiAoY3J5cHRvICYmIGNyeXB0by5uYW1lKSB7XHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgc2VudGltZW50IGJhc2VkIG9uIHByaWNlIGNoYW5nZSB3aXRoIGZpeGVkIHRocmVzaG9sZHNcclxuICAgICAgICAgIGxldCBzZW50aW1lbnQgPSAnTmV1dHJhbCc7XHJcbiAgICAgICAgICBjb25zdCBwcmljZUNoYW5nZSA9IGNyeXB0by5wcmljZUNoYW5nZTI0aCB8fCAwO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBVc2Ugc3RyaWN0ZXIgdGhyZXNob2xkcyB0byBtYWtlIHNlbnRpbWVudCBtb3JlIHN0YWJsZVxyXG4gICAgICAgICAgaWYgKHByaWNlQ2hhbmdlID4gMi41KSBzZW50aW1lbnQgPSAnUG9zaXRpdmUnO1xyXG4gICAgICAgICAgZWxzZSBpZiAocHJpY2VDaGFuZ2UgPCAtMi41KSBzZW50aW1lbnQgPSAnTmVnYXRpdmUnO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBGaXhlZCBuZXdzIGNvdW50IGJhc2VkIG9uIGNyeXB0byB0eXBlIHJhdGhlciB0aGFuIHVzaW5nIHJhbmRvbSBudW1iZXJzXHJcbiAgICAgICAgICBsZXQgbmV3c0NvdW50O1xyXG4gICAgICAgICAgaWYgKGNyeXB0by5zeW1ib2wgPT09ICdCVEMnKSBuZXdzQ291bnQgPSAyNTtcclxuICAgICAgICAgIGVsc2UgaWYgKGNyeXB0by5zeW1ib2wgPT09ICdFVEgnKSBuZXdzQ291bnQgPSAyMDtcclxuICAgICAgICAgIGVsc2UgaWYgKFsnQk5CJywgJ1NPTCcsICdBREEnLCAnWFJQJ10uaW5jbHVkZXMoY3J5cHRvLnN5bWJvbCkpIG5ld3NDb3VudCA9IDE1O1xyXG4gICAgICAgICAgZWxzZSBpZiAoWydET1QnLCAnRE9HRScsICdNQVRJQycsICdBVkFYJywgJ0xJTksnXS5pbmNsdWRlcyhjcnlwdG8uc3ltYm9sKSkgbmV3c0NvdW50ID0gMTI7XHJcbiAgICAgICAgICBlbHNlIG5ld3NDb3VudCA9IDg7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHRhYmxlUm93cy5wdXNoKHtcclxuICAgICAgICAgICAgcHJvamVjdDogY3J5cHRvLm5hbWUsXHJcbiAgICAgICAgICAgIHR2bDogJ04vQScsXHJcbiAgICAgICAgICAgIHR2bENoYW5nZTogJ04vQScsXHJcbiAgICAgICAgICAgIHByaWNlOiBmb3JtYXRDdXJyZW5jeShjcnlwdG8ucHJpY2UgfHwgMCksXHJcbiAgICAgICAgICAgIHByaWNlQ2hhbmdlOiBmb3JtYXRQZXJjZW50YWdlKHByaWNlQ2hhbmdlKSxcclxuICAgICAgICAgICAgc2VudGltZW50OiBzZW50aW1lbnQsXHJcbiAgICAgICAgICAgIG5ld3NDb3VudDogbmV3c0NvdW50XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBJZiBzdGlsbCBubyBkYXRhLCBjcmVhdGUgcGxhY2Vob2xkZXIgZGF0YVxyXG4gICAgaWYgKHRhYmxlUm93cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfkq0gQ3JlYXRpbmcgcGxhY2Vob2xkZXIgZGF0YScpO1xyXG4gICAgICBcclxuICAgICAgLy8gRGVmYXVsdCBwbGFjZWhvbGRlciBjcnlwdG8gbmFtZXNcclxuICAgICAgY29uc3QgcGxhY2Vob2xkZXJQcm9qZWN0cyA9IFsnQml0Y29pbicsICdFdGhlcmV1bScsICdCTkInLCAnU29sYW5hJywgJ0NhcmRhbm8nXTtcclxuICAgICAgXHJcbiAgICAgIC8vIEFkZCBwbGFjZWhvbGRlciBkYXRhIHdpdGggY29uc2lzdGVudCwgbm9uLXJhbmRvbSBzZW50aW1lbnQgdmFsdWVzXHJcbiAgICAgIC8vIFVzZSBwcmVkZWZpbmVkIHNlbnRpbWVudHMgYmFzZWQgb24gdGhlIHByb2plY3QgbmFtZSB0byBlbnN1cmUgY29uc2lzdGVuY3lcclxuICAgICAgY29uc3QgcHJvamVjdFNlbnRpbWVudHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XHJcbiAgICAgICAgJ0JpdGNvaW4nOiAnUG9zaXRpdmUnLFxyXG4gICAgICAgICdFdGhlcmV1bSc6ICdQb3NpdGl2ZScsXHJcbiAgICAgICAgJ0JOQic6ICdOZXV0cmFsJyxcclxuICAgICAgICAnU29sYW5hJzogJ1Bvc2l0aXZlJyxcclxuICAgICAgICAnQ2FyZGFubyc6ICdOZXV0cmFsJ1xyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgcGxhY2Vob2xkZXJQcm9qZWN0cy5mb3JFYWNoKHByb2plY3QgPT4ge1xyXG4gICAgICAgIC8vIFVzZSBwcmVkZWZpbmVkIHNlbnRpbWVudCBvciBkZWZhdWx0IHRvIE5ldXRyYWxcclxuICAgICAgICBjb25zdCBzZW50aW1lbnQgPSBwcm9qZWN0U2VudGltZW50c1twcm9qZWN0XSB8fCAnTmV1dHJhbCc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVXNlIGZpeGVkIG5ld3MgY291bnQgdmFsdWVzIGluc3RlYWQgb2YgcmFuZG9tIG51bWJlcnNcclxuICAgICAgICBjb25zdCBuZXdzQ291bnQgPSBcclxuICAgICAgICAgIHByb2plY3QgPT09ICdCaXRjb2luJyA/IDI1IDogXHJcbiAgICAgICAgICBwcm9qZWN0ID09PSAnRXRoZXJldW0nID8gMjAgOiBcclxuICAgICAgICAgIHByb2plY3QgPT09ICdCTkInID8gMTUgOlxyXG4gICAgICAgICAgcHJvamVjdCA9PT0gJ1NvbGFuYScgPyAxMiA6XHJcbiAgICAgICAgICBwcm9qZWN0ID09PSAnQ2FyZGFubycgPyAxMCA6IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICB0YWJsZVJvd3MucHVzaCh7XHJcbiAgICAgICAgICBwcm9qZWN0OiBwcm9qZWN0LFxyXG4gICAgICAgICAgdHZsOiAnTi9BJyxcclxuICAgICAgICAgIHR2bENoYW5nZTogJ04vQScsXHJcbiAgICAgICAgICBwcmljZTogJ04vQScsXHJcbiAgICAgICAgICBwcmljZUNoYW5nZTogJ04vQScsXHJcbiAgICAgICAgICBzZW50aW1lbnQ6IHNlbnRpbWVudCxcclxuICAgICAgICAgIG5ld3NDb3VudDogbmV3c0NvdW50XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGDinIUgR2VuZXJhdGVkICR7dGFibGVSb3dzLmxlbmd0aH0gdGFibGUgcm93c2ApO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGRhdGEgdGFibGU6JywgZXJyb3IpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gdGFibGVSb3dzO1xyXG59XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBmb3JtYXR0aW5nXHJcbmZ1bmN0aW9uIGZvcm1hdEN1cnJlbmN5KHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IGlzTmFOKHZhbHVlKSkgcmV0dXJuICdOL0EnO1xyXG4gIFxyXG4gIGlmICh2YWx1ZSA+PSAxZTkpIHtcclxuICAgIHJldHVybiBgJCR7KHZhbHVlIC8gMWU5KS50b0ZpeGVkKDIpfUJgO1xyXG4gIH0gZWxzZSBpZiAodmFsdWUgPj0gMWU2KSB7XHJcbiAgICByZXR1cm4gYCQkeyh2YWx1ZSAvIDFlNikudG9GaXhlZCgyKX1NYDtcclxuICB9IGVsc2UgaWYgKHZhbHVlID49IDFlMykge1xyXG4gICAgcmV0dXJuIGAkJHsodmFsdWUgLyAxZTMpLnRvRml4ZWQoMil9S2A7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgJCR7dmFsdWUudG9GaXhlZCgyKX1gO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0UGVyY2VudGFnZSh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHtcclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCBpc05hTih2YWx1ZSkpIHJldHVybiAnMCUnO1xyXG4gIHJldHVybiBgJHt2YWx1ZSA+IDAgPyAnKycgOiAnJ30ke3ZhbHVlLnRvRml4ZWQoMil9JWA7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhbmFseXplQ3J5cHRvRGF0YShxdWVyeTogc3RyaW5nLCBkYXRhOiBhbnkpOiBQcm9taXNlPFJlc2VhcmNoUmVzdWx0PiB7XHJcbiAgY29uc29sZS5sb2coJ/CflI0gRmV0Y2hpbmcgZGF0YSBmb3IgcXVlcnk6JywgcXVlcnkpO1xyXG4gIGNvbnNvbGUubG9nKCfwn5WSIFF1ZXJ5IHRpbWVzdGFtcDonLCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpO1xyXG4gIFxyXG4gIC8vIEV4dHJhY3QgZm9jdXMgdG9rZW5zIGFuZCBwcm9qZWN0c1xyXG4gIGNvbnN0IGZvY3VzVG9rZW5zID0gZXh0cmFjdFRva2VucyhxdWVyeSk7XHJcbiAgY29uc3QgZm9jdXNQcm9qZWN0cyA9IGV4dHJhY3RQcm9qZWN0cyhxdWVyeSk7XHJcbiAgY29uc3QgdGltZUZyYW1lID0gZXh0cmFjdFRpbWVGcmFtZShxdWVyeSk7XHJcbiAgY29uc3QgdXNlVHJlbmRpbmcgPSBxdWVyeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd0cmVuZGluZycpIHx8IHF1ZXJ5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3BvcHVsYXInKTtcclxuICBjb25zdCB1c2VSYW5kb21PcmRlciA9ICFmb2N1c1Rva2Vucy5sZW5ndGggJiYgIWZvY3VzUHJvamVjdHMubGVuZ3RoO1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKCfwn46vIEZvY3VzIHRva2VuczonLCBmb2N1c1Rva2Vucyk7XHJcbiAgY29uc29sZS5sb2coJ/Cfjq8gRm9jdXMgcHJvamVjdHM6JywgZm9jdXNQcm9qZWN0cyk7XHJcbiAgY29uc29sZS5sb2coJ+KPsCBUaW1lIGZyYW1lOicsIHRpbWVGcmFtZSk7XHJcbiAgY29uc29sZS5sb2coJ/Cfk4ggVXNpbmcgdHJlbmRpbmcgZGF0YTonLCB1c2VUcmVuZGluZyk7XHJcbiAgY29uc29sZS5sb2coJ/CflIQgVXNpbmcgcmFuZG9tIG9yZGVyOicsIHVzZVJhbmRvbU9yZGVyKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIEZldGNoIGRhdGFcclxuICAgIGNvbnN0IGFsbERhdGEgPSBhd2FpdCBmZXRjaEFsbERhdGEocXVlcnkpO1xyXG4gICAgY29uc29sZS5sb2coJ/Cfk4ogRmV0Y2hlZCBkYXRhIHN1bW1hcnk6Jywge1xyXG4gICAgICBjcnlwdG9EYXRhQ291bnQ6IGFsbERhdGEuY3J5cHRvRGF0YT8ubGVuZ3RoIHx8IDAsXHJcbiAgICAgIGRlZmlQcm9qZWN0c0NvdW50OiBhbGxEYXRhLmRlZmlQcm9qZWN0cz8ubGVuZ3RoIHx8IDBcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIGFuYWx5c2lzIHVzaW5nIEdyb3Egd2l0aCBmYWxsYmFjayBtb2RlbHNcclxuICAgIGNvbnN0IGFuYWx5c2lzID0gYXdhaXQgZ2VuZXJhdGVBbmFseXNpc1dpdGhGYWxsYmFjayhxdWVyeSwgYWxsRGF0YSk7XHJcbiAgICBcclxuICAgIC8vIFRyYW5zZm9ybSBkYXRhIHRvIG1hdGNoIFJlc2VhcmNoUmVzdWx0IGludGVyZmFjZVxyXG4gICAgY29uc3QgdHJhbnNmb3JtZWREYXRhID0ge1xyXG4gICAgICBjcnlwdG9EYXRhOiBhbGxEYXRhLmNyeXB0b0RhdGEgfHwgW10sXHJcbiAgICAgIGRlZmlQcm9qZWN0czogYWxsRGF0YS5kZWZpUHJvamVjdHMgfHwgW10sXHJcbiAgICAgIHNvY2lhbFNlbnRpbWVudDogYWxsRGF0YS5zb2NpYWxTZW50aW1lbnQgfHwgW10sXHJcbiAgICAgIG5ld3NFdmVudHM6IGFsbERhdGEubmV3c0V2ZW50cyB8fCBbXSxcclxuICAgICAgZXRoZXJzY2FuRGF0YTogYWxsRGF0YS5ldGhlcnNjYW5EYXRhIHx8IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gUmVmaW5lIGRhdGEgdGFibGUgZm9yIGV4cGxpY2l0IGNvbXBhcmlzb24gcXVlcmllcyAoZS5nLiwgXCJDb21wYXJlIEV0aGVyZXVtIGFuZCBTb2xhbmFcIilcclxuICAgIGNvbnN0IHJlZmluZWRUYWJsZSA9IHJlZmluZUNvbXBhcmlzb25UYWJsZShxdWVyeSwgdHJhbnNmb3JtZWREYXRhLCBhbmFseXNpcy5kYXRhVGFibGUgfHwgW10pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1bW1hcnk6IGFuYWx5c2lzLnN1bW1hcnksXHJcbiAgICAgIGRhdGE6IHRyYW5zZm9ybWVkRGF0YSxcclxuICAgICAgZGF0YVRhYmxlOiByZWZpbmVkVGFibGUsXHJcbiAgICAgIHNvdXJjZXM6IGFuYWx5c2lzLnNvdXJjZXMsXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBzaG93RGVGaTogQm9vbGVhbihhbGxEYXRhLmRlZmlQcm9qZWN0cyAmJiBhbGxEYXRhLmRlZmlQcm9qZWN0cy5sZW5ndGggPiAwKSxcclxuICAgICAgc2hvd1RhYmxlOiBCb29sZWFuKGFuYWx5c2lzLmRhdGFUYWJsZSAmJiBhbmFseXNpcy5kYXRhVGFibGUubGVuZ3RoID4gMCksXHJcbiAgICAgIHNob3dFdGhlcnNjYW46IEJvb2xlYW4oYWxsRGF0YS5ldGhlcnNjYW5EYXRhICYmIE9iamVjdC5rZXlzKGFsbERhdGEuZXRoZXJzY2FuRGF0YSB8fCB7fSkubGVuZ3RoID4gMCksXHJcbiAgICAgIGlzQ3J5cHRvUXVlcnk6IHRydWUsXHJcbiAgICAgIGluc2lnaHRzOiBhbmFseXNpcy5pbnNpZ2h0cyB8fCBbXSxcclxuICAgICAgcmlza0ZhY3RvcnM6IGFuYWx5c2lzLnJpc2tGYWN0b3JzIHx8IFtdLFxyXG4gICAgICBtYXJrZXRUcmVuZHM6IGFuYWx5c2lzLm1hcmtldFRyZW5kcyB8fCAnJ1xyXG4gICAgfTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBhbmFseXplQ3J5cHRvRGF0YTonLCBlcnJvcik7XHJcbiAgICBcclxuICAgIC8vIFJldHVybiBhIGJhc2ljIGZhbGxiYWNrIHJlc3BvbnNlXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdW1tYXJ5OiBgQW5hbHlzaXMgY29tcGxldGVkLiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnfWAsXHJcbiAgICAgIGRhdGE6IHt9LFxyXG4gICAgICBzb3VyY2VzOiBbJ0ZhbGxiYWNrIEFuYWx5c2lzJ10sXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBzaG93RGVGaTogZmFsc2UsXHJcbiAgICAgIHNob3dUYWJsZTogZmFsc2UsXHJcbiAgICAgIHNob3dFdGhlcnNjYW46IGZhbHNlLFxyXG4gICAgICBpc0NyeXB0b1F1ZXJ5OiB0cnVlLFxyXG4gICAgICBpbnNpZ2h0czogWydBbmFseXNpcyBjb21wbGV0ZWQgd2l0aCBiYXNpYyBtZXRob2QnXSxcclxuICAgICAgcmlza0ZhY3RvcnM6IFsnVXNlIHN0YW5kYXJkIG1vZGUgZm9yIG1vcmUgcmVsaWFibGUgcmVzcG9uc2VzJ10sXHJcbiAgICAgIG1hcmtldFRyZW5kczogJ1VuYWJsZSB0byBjb21wbGV0ZSBmdWxsIGFuYWx5c2lzJ1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQW5hbHlzaXNXaXRoRmFsbGJhY2socXVlcnk6IHN0cmluZywgZGF0YTogYW55LCBtYXhSZXRyaWVzID0gMyk6IFByb21pc2U8YW55PiB7XHJcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gbWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyBHcm9xIEFQSSBjYWxsIChhdHRlbXB0ICR7YXR0ZW1wdH0vJHttYXhSZXRyaWVzfSkuLi5gKTtcclxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRHcm9xTW9kZWwoKTtcclxuICAgICAgY29uc29sZS5sb2coYFVzaW5nIG1vZGVsOiAke21vZGVsfSAocmV0cnkgYXR0ZW1wdDogJHthdHRlbXB0IC0gMX0pYCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBncm9xID0gbmV3IEdyb3Eoe1xyXG4gICAgICAgIGFwaUtleTogcHJvY2Vzcy5lbnYuR1JPUV9BUElfS0VZLFxyXG4gICAgICB9KTtcclxuICAgICAgLy8gLS0tIERBVEEgUkVEVUNUSU9OIC8gVE9LRU4gQlVER0VUSU5HIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBXZSBhZ2dyZXNzaXZlbHkgdHJpbSB0aGUgZGF0YXNldCBiZWZvcmUgc2VuZGluZyB0byB0aGUgbW9kZWwgdG8gYXZvaWQgNDEzXHJcbiAgICAgIGNvbnN0IHJlZHVjZWQgPSByZWR1Y2VEYXRhRm9yTW9kZWwoZGF0YSwgcXVlcnksIGF0dGVtcHQpO1xyXG4gICAgICBjb25zdCByZWR1Y2VkSnNvbiA9IEpTT04uc3RyaW5naWZ5KHJlZHVjZWQpOyAvLyBubyBwcmV0dHkgcHJpbnQgdG8gc2F2ZSB0b2tlbnNcclxuICAgICAgY29uc3QgYXBwcm94SW5wdXRUb2tlbnMgPSBNYXRoLmNlaWwocmVkdWNlZEpzb24ubGVuZ3RoIC8gNCk7IC8vIHJvdWdoIGhldXJpc3RpY1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+XnO+4jyBSZWR1Y2VkIGRhdGEgbGVuZ3RoOiAke3JlZHVjZWRKc29uLmxlbmd0aH0gY2hhcnMgKH4ke2FwcHJveElucHV0VG9rZW5zfSB0b2tlbnMpYCk7XHJcbiAgICAgIGlmIChhcHByb3hJbnB1dFRva2VucyA+IDU1MDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBTdGlsbCBhYm92ZSBzYWZlIHRva2VuIGJ1ZGdldCBhZnRlciByZWR1Y3Rpb24g4oCTIGFwcGx5aW5nIGhhcmQgdHJpbScpO1xyXG4gICAgICAgIC8vIEhhcmQgdHJpbToga2VlcCBvbmx5IGVzc2VudGlhbCBhZ2dyZWdhdGVzXHJcbiAgICAgICAgY29uc3QgaGFyZFRyaW0gPSB7XHJcbiAgICAgICAgICBtZXRhOiByZWR1Y2VkLm1ldGEsXHJcbiAgICAgICAgICBhZ2dyZWdhdGVzOiByZWR1Y2VkLmFnZ3JlZ2F0ZXMsXHJcbiAgICAgICAgICB0b3BDcnlwdG86IHJlZHVjZWQuY3J5cHRvRGF0YT8uc2xpY2UoMCwgNSksXHJcbiAgICAgICAgICB0b3BEZUZpOiByZWR1Y2VkLmRlZmlQcm9qZWN0cz8uc2xpY2UoMCwgNSksXHJcbiAgICAgICAgICBuZXdzOiByZWR1Y2VkLm5ld3NFdmVudHM/LnNsaWNlKDAsIDUpPy5tYXAoKG46IGFueSkgPT4gKHsgdDogbi50aXRsZSwgZDogbi5wdWJsaXNoZWRBdCB9KSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGhhcmRUcmltSnNvbiA9IEpTT04uc3RyaW5naWZ5KGhhcmRUcmltKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+qkyBIYXJkIHRyaW1tZWQgbGVuZ3RoOiAke2hhcmRUcmltSnNvbi5sZW5ndGh9IGNoYXJzICh+JHtNYXRoLmNlaWwoaGFyZFRyaW1Kc29uLmxlbmd0aC80KX0gdG9rZW5zKWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSAnWW91IGFyZSBhbiBleHBlcnQgY3J5cHRvIGFuYWx5c3QuIFJlc3BvbmQgT05MWSB3aXRoIGEgbWluaWZpZWQgSlNPTiBvYmplY3QuIE5vIG1hcmtkb3duLCBubyBjb21tZW50YXJ5Lic7XHJcbiAgICAgIGNvbnN0IHVzZXJQcm9tcHQgPSBgUXVlcnk6ICR7cXVlcnl9XFxuRGF0YToke3JlZHVjZWRKc29ufVxcblJldHVybiBKU09OIHdpdGgga2V5czogc3VtbWFyeSAoc3RyaW5nKSwgaW5zaWdodHMgKHN0cmluZ1tdIG1heCA2KSwgcmlza0ZhY3RvcnMgKHN0cmluZ1tdIG1heCA2KSwgbWFya2V0VHJlbmRzIChzdHJpbmcpLCBzb3VyY2VzIChzdHJpbmdbXSksIGRhdGFUYWJsZSAocm93cyA8PSAxMCwgZmllbGRzOiBwcm9qZWN0LHR2bCx0dmxDaGFuZ2UscHJpY2UscHJpY2VDaGFuZ2Usc2VudGltZW50LG5ld3NDb3VudCkuYDtcclxuXHJcbiAgICAgIGNvbnN0IGNvbXBsZXRpb24gPSBhd2FpdCBncm9xLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcclxuICAgICAgICBtZXNzYWdlczogW1xyXG4gICAgICAgICAgeyByb2xlOiAnc3lzdGVtJywgY29udGVudDogc3lzdGVtUHJvbXB0IH0sXHJcbiAgICAgICAgICB7IHJvbGU6ICd1c2VyJywgY29udGVudDogdXNlclByb21wdCB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBtb2RlbCxcclxuICAgICAgICB0ZW1wZXJhdHVyZTogMC4xLFxyXG4gICAgICAgIG1heF90b2tlbnM6IDE0MDAsXHJcbiAgICAgICAgdG9wX3A6IDEsXHJcbiAgICAgICAgc3RyZWFtOiBmYWxzZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGNvbXBsZXRpb24uY2hvaWNlc1swXT8ubWVzc2FnZT8uY29udGVudDtcclxuICAgICAgaWYgKCFyZXNwb25zZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgcmVzcG9uc2UgZnJvbSBHcm9xJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRyeSB0byBwYXJzZSBKU09OIGZyb20gdGhlIHJlc3BvbnNlXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QganNvbk1hdGNoID0gcmVzcG9uc2UubWF0Y2goL1xce1tcXHNcXFNdKlxcfS8pO1xyXG4gICAgICAgIGlmIChqc29uTWF0Y2gpIHtcclxuICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25NYXRjaFswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdKU09OIHBhcnNpbmcgZmFpbGVkLCB1c2luZyB0ZXh0IHJlc3BvbnNlJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZhbGxiYWNrOiBjcmVhdGUgc3RydWN0dXJlZCByZXNwb25zZSBmcm9tIHRleHRcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdW1tYXJ5OiByZXNwb25zZSxcclxuICAgICAgICBpbnNpZ2h0czogWydBbmFseXNpcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5J10sXHJcbiAgICAgICAgcmlza0ZhY3RvcnM6IFsnQ29uc2lkZXIgbWFya2V0IHZvbGF0aWxpdHknXSxcclxuICAgICAgICBtYXJrZXRUcmVuZHM6ICdNYXJrZXQgYW5hbHlzaXMgY29tcGxldGVkJyxcclxuICAgICAgICBzb3VyY2VzOiBbJ0dyb3EgQUkgQW5hbHlzaXMnXSxcclxuICAgICAgICBkYXRhVGFibGU6IFtdXHJcbiAgICAgIH07XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBHcm9xIEFQSSBlcnJvciAoJHtlcnJvci5zdGF0dXMgPT09IDQyOSA/ICdyYXRlIGxpbWl0JyA6ICdnZW5lcmFsIGVycm9yJ30pOmAsIGVycm9yLnN0YXR1cywgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgIC8vIEhhbmRsZSBwYXlsb2FkIHRvbyBsYXJnZSAvIHRva2VuIGxpbWl0IG1lc3NhZ2UgKDQxMyBvciB0b2tlbiBzaXplIG5vdGljZSlcclxuICAgICAgY29uc3QgbXNnOiBzdHJpbmcgPSBlcnJvcj8ubWVzc2FnZSB8fCAnJztcclxuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDEzIHx8IG1zZy5pbmNsdWRlcygnUmVxdWVzdCB0b28gbGFyZ2UnKSB8fCBtc2cuaW5jbHVkZXMoJ3Rva2VucyBwZXIgbWludXRlJykgKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCfwn5SBIE92ZXJzaXplZCByZXF1ZXN0IGRldGVjdGVkLCBmdXJ0aGVyIHJlZHVjaW5nIGRhdGEgJiBzd2l0Y2hpbmcgbW9kZWwnKTtcclxuICAgICAgICBuZXh0TW9kZWwoKTtcclxuICAgICAgICBpZiAoYXR0ZW1wdCA8IG1heFJldHJpZXMpIHtcclxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCA1MDAgKiBhdHRlbXB0KSk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSYXRlIGxpbWl0IGhpdCwgdHJ5aW5nIG5leHQgbW9kZWwuLi4nKTtcclxuICAgICAgICBuZXh0TW9kZWwoKTtcclxuICAgICAgICBpZiAoYXR0ZW1wdCA8IG1heFJldHJpZXMpIHtcclxuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5taW4oMTAwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQpLCAxMDAwMCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUmV0cnlpbmcgaW4gJHtkZWxheX1tcyB3aXRoIG1vZGVsIGZhbGxiYWNrLi4uYCk7XHJcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGF0dXMgPT09IDQwNCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2RlbCBub3QgZm91bmQsIHRyeWluZyBuZXh0IG1vZGVsLi4uJyk7XHJcbiAgICAgICAgbmV4dE1vZGVsKCk7XHJcbiAgICAgICAgaWYgKGF0dGVtcHQgPCBtYXhSZXRyaWVzKSB7XHJcbiAgICAgICAgICBjb25zdCBkZWxheSA9IDIwMDAgKiBhdHRlbXB0O1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFJldHJ5aW5nIGluICR7ZGVsYXl9bXMgd2l0aCBtb2RlbCBmYWxsYmFjay4uLmApO1xyXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBHcm9xIG1vZGVscyBmYWlsZWQnKTtcclxufVxyXG5cclxuLy8gUmVkdWNlIHJhdyBmZXRjaGVkIGRhdGEgdG8gYSBjb21wYWN0LCBtb2RlbC1mcmllbmRseSBzdWJzZXQuXHJcbmZ1bmN0aW9uIHJlZHVjZURhdGFGb3JNb2RlbChkYXRhOiBhbnksIHF1ZXJ5OiBzdHJpbmcsIGF0dGVtcHQ6IG51bWJlcikge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBxTG93ZXIgPSAocXVlcnkgfHwgJycpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCBmb2N1c1Rva2VucyA9IGV4dHJhY3RUb2tlbnMocXVlcnkgfHwgJycpO1xyXG4gICAgY29uc3QgbWF4RGVGaSA9IGF0dGVtcHQgPT09IDEgPyAxNSA6IGF0dGVtcHQgPT09IDIgPyAxMCA6IDU7XHJcbiAgICBjb25zdCBtYXhDcnlwdG8gPSBhdHRlbXB0ID09PSAxID8gMTIgOiBhdHRlbXB0ID09PSAyID8gOCA6IDU7XHJcbiAgICBjb25zdCBtYXhOZXdzID0gYXR0ZW1wdCA9PT0gMSA/IDIwIDogYXR0ZW1wdCA9PT0gMiA/IDEwIDogNTtcclxuXHJcbiAgICBjb25zdCBjcnlwdG9EYXRhID0gKGRhdGEuY3J5cHRvRGF0YSB8fCBbXSlcclxuICAgICAgLmZpbHRlcigoYzogYW55KSA9PiBmb2N1c1Rva2Vucy5sZW5ndGggPyBmb2N1c1Rva2Vucy5pbmNsdWRlcyhjLnN5bWJvbCkgOiB0cnVlKVxyXG4gICAgICAuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IChiLm1hcmtldENhcCB8fCAwKSAtIChhLm1hcmtldENhcCB8fCAwKSlcclxuICAgICAgLnNsaWNlKDAsIG1heENyeXB0bylcclxuICAgICAgLm1hcCgoYzogYW55KSA9PiAoe1xyXG4gICAgICAgIHN5bWJvbDogYy5zeW1ib2wsXHJcbiAgICAgICAgbmFtZTogYy5uYW1lLFxyXG4gICAgICAgIHByaWNlOiBjLnByaWNlLFxyXG4gICAgICAgIHByaWNlQ2hhbmdlMjRoOiBjLnByaWNlQ2hhbmdlMjRoLFxyXG4gICAgICAgIG1hcmtldENhcDogYy5tYXJrZXRDYXAsXHJcbiAgICAgICAgdm9sdW1lMjRoOiBjLnZvbHVtZTI0aFxyXG4gICAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgZGVmaVByb2plY3RzID0gKGRhdGEuZGVmaVByb2plY3RzIHx8IFtdKVxyXG4gICAgICAuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IChiLnR2bCB8fCAwKSAtIChhLnR2bCB8fCAwKSlcclxuICAgICAgLnNsaWNlKDAsIG1heERlRmkpXHJcbiAgICAgIC5tYXAoKHA6IGFueSkgPT4gKHtcclxuICAgICAgICBuYW1lOiBwLm5hbWUsXHJcbiAgICAgICAgdHZsOiBwLnR2bCxcclxuICAgICAgICB0dmxDaGFuZ2UyNGg6IHAudHZsQ2hhbmdlMjRoLFxyXG4gICAgICAgIHR2bENoYW5nZTdkOiBwLnR2bENoYW5nZTdkLFxyXG4gICAgICAgIGNoYWluczogcC5jaGFpbnM/LnNsaWNlKDAsIDUpXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICBjb25zdCBuZXdzRXZlbnRzID0gKGRhdGEubmV3c0V2ZW50cyB8fCBbXSlcclxuICAgICAgLnNsaWNlKDAsIG1heE5ld3MpXHJcbiAgICAgIC5tYXAoKG46IGFueSkgPT4gKHsgdGl0bGU6IG4udGl0bGUsIHNlbnRpbWVudDogbi5zZW50aW1lbnQsIHB1Ymxpc2hlZEF0OiBuLnB1Ymxpc2hlZEF0IH0pKTtcclxuXHJcbiAgICBjb25zdCBldGhlcnNjYW5HYXMgPSBkYXRhLmV0aGVyc2NhbkRhdGE/Lmdhc1ByaWNlID8ge1xyXG4gICAgICBMYXN0QmxvY2s6IGRhdGEuZXRoZXJzY2FuRGF0YS5nYXNQcmljZS5MYXN0QmxvY2ssXHJcbiAgICAgIFNhZmVHYXNQcmljZTogZGF0YS5ldGhlcnNjYW5EYXRhLmdhc1ByaWNlLlNhZmVHYXNQcmljZSxcclxuICAgICAgRmFzdDogZGF0YS5ldGhlcnNjYW5EYXRhLmdhc1ByaWNlLkZhc3RcclxuICAgIH0gOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gQWdncmVnYXRlcyB0byBoZWxwIG1vZGVsIHdpdGhvdXQgZnVsbCByYXcgYXJyYXlzXHJcbiAgICBjb25zdCB0dmxUb3RhbCA9IChkYXRhLmRlZmlQcm9qZWN0cyB8fCBbXSkucmVkdWNlKChzOiBudW1iZXIsIHA6IGFueSkgPT4gcyArIChwLnR2bCB8fCAwKSwgMCk7XHJcbiAgICBjb25zdCBhdmdQcmljZUNoYW5nZSA9IGNyeXB0b0RhdGEubGVuZ3RoID8gKGNyeXB0b0RhdGEucmVkdWNlKChzOiBudW1iZXIsIGM6IGFueSkgPT4gcyArIChjLnByaWNlQ2hhbmdlMjRoIHx8IDApLCAwKSAvIGNyeXB0b0RhdGEubGVuZ3RoKSA6IDA7XHJcblxyXG4gICAgY29uc3QgZ2VuZXJhdGVkVGFibGUgPSBnZW5lcmF0ZURhdGFUYWJsZUZyb21SYXdEYXRhKHtcclxuICAgICAgZGVmaVByb2plY3RzLFxyXG4gICAgICBjcnlwdG9EYXRhLFxyXG4gICAgICBuZXdzRXZlbnRzXHJcbiAgICB9LCBxdWVyeSkuc2xpY2UoMCwgMTApOyAvLyBlbnN1cmUgbWF4IDEwIHJvd3NcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBtZXRhOiB7XHJcbiAgICAgICAgYXR0ZW1wdCxcclxuICAgICAgICBmb2N1c1Rva2VucyxcclxuICAgICAgICBxdWVyeUZyYWdtZW50OiBxdWVyeS5zbGljZSgwLCAxNjApXHJcbiAgICAgIH0sXHJcbiAgICAgIGFnZ3JlZ2F0ZXM6IHtcclxuICAgICAgICB0dmxUb3RhbCxcclxuICAgICAgICBhdmdQcmljZUNoYW5nZTogTnVtYmVyKGF2Z1ByaWNlQ2hhbmdlLnRvRml4ZWQoMikpLFxyXG4gICAgICAgIGRlZmlDb3VudDogKGRhdGEuZGVmaVByb2plY3RzIHx8IFtdKS5sZW5ndGgsXHJcbiAgICAgICAgY3J5cHRvQ291bnQ6IChkYXRhLmNyeXB0b0RhdGEgfHwgW10pLmxlbmd0aCxcclxuICAgICAgICBuZXdzQ291bnQ6IChkYXRhLm5ld3NFdmVudHMgfHwgW10pLmxlbmd0aFxyXG4gICAgICB9LFxyXG4gICAgICBjcnlwdG9EYXRhLFxyXG4gICAgICBkZWZpUHJvamVjdHMsXHJcbiAgICAgIG5ld3NFdmVudHMsXHJcbiAgICAgIGV0aGVyc2NhbjogZXRoZXJzY2FuR2FzLFxyXG4gICAgICAvLyBQcm92aWRlIGFscmVhZHkgZ2VuZXJhdGVkIGRhdGFUYWJsZSB0byByZWR1Y2UgbW9kZWwgd29ya1xyXG4gICAgICBzdWdnZXN0ZWRUYWJsZTogZ2VuZXJhdGVkVGFibGVcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdyZWR1Y2VEYXRhRm9yTW9kZWwgZmFpbGVkLCByZXR1cm5pbmcgbWluaW1hbCBzdHJ1Y3R1cmUnLCBlKTtcclxuICAgIHJldHVybiB7IG1ldGE6IHsgYXR0ZW1wdCwgZXJyb3I6IHRydWUgfSwgY3J5cHRvRGF0YTogW10sIGRlZmlQcm9qZWN0czogW10gfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEZhbGxiYWNrIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgY2xlYW4gc3VtbWFyeSBmcm9tIGF2YWlsYWJsZSBkYXRhXHJcbmZ1bmN0aW9uIGdlbmVyYXRlRmFsbGJhY2tTdW1tYXJ5KGRhdGE6IGFueSwgcXVlcnk6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgbGV0IHN1bW1hcnkgPSAnJztcclxuICBcclxuICB0cnkge1xyXG4gICAgLy8gRXh0cmFjdCBxdWVyeSBrZXl3b3JkcyB0byBtYWtlIHRoZSByZXNwb25zZSBtb3JlIHJlbGV2YW50XHJcbiAgICBjb25zdCBxdWVyeUxvd2VyID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IG1lbnRpb25zQml0Y29pbiA9IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2JpdGNvaW4nKSB8fCBxdWVyeUxvd2VyLmluY2x1ZGVzKCdidGMnKTtcclxuICAgIGNvbnN0IG1lbnRpb25zRXRoZXJldW0gPSBxdWVyeUxvd2VyLmluY2x1ZGVzKCdldGhlcmV1bScpIHx8IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2V0aCcpO1xyXG4gICAgY29uc3QgbWVudGlvbnNEZUZpID0gcXVlcnlMb3dlci5pbmNsdWRlcygnZGVmaScpIHx8IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ3Byb3RvY29sJykgfHwgcXVlcnlMb3dlci5pbmNsdWRlcygndHZsJyk7XHJcbiAgICBjb25zdCBtZW50aW9uc1ByaWNlID0gcXVlcnlMb3dlci5pbmNsdWRlcygncHJpY2UnKSB8fCBxdWVyeUxvd2VyLmluY2x1ZGVzKCdtYXJrZXQnKSB8fCBxdWVyeUxvd2VyLmluY2x1ZGVzKCd0cmFkaW5nJyk7XHJcbiAgICBjb25zdCBtZW50aW9uc1RvcCA9IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ3RvcCcpIHx8IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2Jlc3QnKSB8fCBxdWVyeUxvd2VyLmluY2x1ZGVzKCdsZWFkaW5nJyk7XHJcbiAgICBcclxuICAgIC8vIEFkZCBwZXJzb25hbGl6ZWQgaW50cm8gYmFzZWQgb24gdGhlIHF1ZXJ5XHJcbiAgICBzdW1tYXJ5ICs9IGBCYXNlZCBvbiB5b3VyIHF1ZXJ5IGFib3V0ICR7bWVudGlvbnNEZUZpID8gJ0RlRmkgcHJvdG9jb2xzJyA6IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW50aW9uc0JpdGNvaW4gPyAnQml0Y29pbicgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVudGlvbnNFdGhlcmV1bSA/ICdFdGhlcmV1bScgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RoZSBjcnlwdG8gbWFya2V0J30sIGhlcmUncyBteSBhbmFseXNpczogXFxuXFxuYDtcclxuICAgIFxyXG4gICAgLy8gQWRkIERlRmkgcHJvamVjdHMgYW5hbHlzaXNcclxuICAgIGlmIChkYXRhLmRlZmlQcm9qZWN0cyAmJiBBcnJheS5pc0FycmF5KGRhdGEuZGVmaVByb2plY3RzKSAmJiBkYXRhLmRlZmlQcm9qZWN0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IHRvcFByb2plY3RzID0gZGF0YS5kZWZpUHJvamVjdHMuc2xpY2UoMCwgMyk7XHJcbiAgICAgIHN1bW1hcnkgKz0gYEFuYWx5c2lzIG9mIHRoZSBEZUZpIG1hcmtldCByZXZlYWxzICR7ZGF0YS5kZWZpUHJvamVjdHMubGVuZ3RofSBhY3RpdmUgcHJvdG9jb2xzLiBgO1xyXG4gICAgICBcclxuICAgICAgaWYgKG1lbnRpb25zVG9wIHx8ICFtZW50aW9uc1ByaWNlKSB7XHJcbiAgICAgICAgc3VtbWFyeSArPSBgVGhlIHRvcCBwZXJmb3JtZXJzIGJ5IFRvdGFsIFZhbHVlIExvY2tlZCAoVFZMKSBpbmNsdWRlICR7dG9wUHJvamVjdHMubWFwKChwOiBhbnkpID0+IHA/Lm5hbWUgfHwgJ1Vua25vd24nKS5qb2luKCcsICcpfS4gYDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgdG90YWxUVkwgPSBkYXRhLmRlZmlQcm9qZWN0cy5yZWR1Y2UoKHN1bTogbnVtYmVyLCBwOiBhbnkpID0+IHN1bSArIChwPy50dmwgfHwgMCksIDApO1xyXG4gICAgICBpZiAodG90YWxUVkwgPiAwKSB7XHJcbiAgICAgICAgc3VtbWFyeSArPSBgVG90YWwgVmFsdWUgTG9ja2VkIGFjcm9zcyBhbGwgcHJvdG9jb2xzIGlzIGFwcHJveGltYXRlbHkgJCR7KHRvdGFsVFZMIC8gMWU5KS50b0ZpeGVkKDEpfUIuIGA7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEFkZCBUVkwgY2hhbmdlIGFuYWx5c2lzIGlmIHdlIGhhdmUgdGhhdCBkYXRhXHJcbiAgICAgIGNvbnN0IHByb2plY3RzV2l0aFRWTENoYW5nZSA9IGRhdGEuZGVmaVByb2plY3RzLmZpbHRlcigocDogYW55KSA9PiBcclxuICAgICAgICB0eXBlb2YgcC50dmxDaGFuZ2U3ZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHAudHZsQ2hhbmdlMjRoID09PSAnbnVtYmVyJ1xyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgaWYgKHByb2plY3RzV2l0aFRWTENoYW5nZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gU29ydCBieSBUVkwgY2hhbmdlXHJcbiAgICAgICAgY29uc3Qgc29ydGVkQnlDaGFuZ2UgPSBbLi4ucHJvamVjdHNXaXRoVFZMQ2hhbmdlXS5zb3J0KChhLCBiKSA9PiBcclxuICAgICAgICAgICgoYi50dmxDaGFuZ2U3ZCB8fCBiLnR2bENoYW5nZTI0aCB8fCAwKSAtIChhLnR2bENoYW5nZTdkIHx8IGEudHZsQ2hhbmdlMjRoIHx8IDApKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgdG9wR2FpbmVyID0gc29ydGVkQnlDaGFuZ2VbMF07XHJcbiAgICAgICAgY29uc3QgdG9wTG9zZXIgPSBzb3J0ZWRCeUNoYW5nZVtzb3J0ZWRCeUNoYW5nZS5sZW5ndGggLSAxXTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodG9wR2FpbmVyICYmICh0b3BHYWluZXIudHZsQ2hhbmdlN2QgPiAwIHx8IHRvcEdhaW5lci50dmxDaGFuZ2UyNGggPiAwKSkge1xyXG4gICAgICAgICAgY29uc3QgY2hhbmdlVmFsdWUgPSB0b3BHYWluZXIudHZsQ2hhbmdlN2QgfHwgdG9wR2FpbmVyLnR2bENoYW5nZTI0aDtcclxuICAgICAgICAgIHN1bW1hcnkgKz0gYCR7dG9wR2FpbmVyLm5hbWV9IHNob3dzIHRoZSBoaWdoZXN0IGdyb3d0aCB3aXRoIGEgJHtjaGFuZ2VWYWx1ZS50b0ZpeGVkKDIpfSUgaW5jcmVhc2UgaW4gVFZMLiBgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAodG9wTG9zZXIgJiYgKHRvcExvc2VyLnR2bENoYW5nZTdkIDwgMCB8fCB0b3BMb3Nlci50dmxDaGFuZ2UyNGggPCAwKSkge1xyXG4gICAgICAgICAgY29uc3QgY2hhbmdlVmFsdWUgPSB0b3BMb3Nlci50dmxDaGFuZ2U3ZCB8fCB0b3BMb3Nlci50dmxDaGFuZ2UyNGg7XHJcbiAgICAgICAgICBzdW1tYXJ5ICs9IGAke3RvcExvc2VyLm5hbWV9IGhhcyBleHBlcmllbmNlZCBhICR7TWF0aC5hYnMoY2hhbmdlVmFsdWUpLnRvRml4ZWQoMil9JSBkZWNyZWFzZSBpbiBUVkwuIGA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEFkZCBjcnlwdG8gbWFya2V0IGRhdGFcclxuICAgIGlmIChkYXRhLmNyeXB0b0RhdGEgJiYgQXJyYXkuaXNBcnJheShkYXRhLmNyeXB0b0RhdGEpICYmIGRhdGEuY3J5cHRvRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIEdldCBjdXJyZW50IGRhdGUgZm9yIGNvbnRleHRcclxuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgY29uc3QgZGF0ZVN0ciA9IG5vdy50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTJywgeyBcclxuICAgICAgICBtb250aDogJ2xvbmcnLCBcclxuICAgICAgICBkYXk6ICdudW1lcmljJywgXHJcbiAgICAgICAgeWVhcjogJ251bWVyaWMnIFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHN1bW1hcnkgKz0gYFxcbkFzIG9mICR7ZGF0ZVN0cn0sIGA7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBidGMgPSBkYXRhLmNyeXB0b0RhdGEuZmluZCgoYzogYW55KSA9PiBjPy5zeW1ib2wgPT09ICdCVEMnKTtcclxuICAgICAgY29uc3QgZXRoID0gZGF0YS5jcnlwdG9EYXRhLmZpbmQoKGM6IGFueSkgPT4gYz8uc3ltYm9sID09PSAnRVRIJyk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoYnRjICYmIHR5cGVvZiBidGMucHJpY2UgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgc3VtbWFyeSArPSBgQml0Y29pbiBpcyBjdXJyZW50bHkgdHJhZGluZyBhdCAkJHtidGMucHJpY2UudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLCB7bWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyfSl9YDtcclxuICAgICAgICBpZiAodHlwZW9mIGJ0Yy5wcmljZUNoYW5nZTI0aCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIHN1bW1hcnkgKz0gYCB3aXRoIGEgMjRoIGNoYW5nZSBvZiAke2J0Yy5wcmljZUNoYW5nZTI0aCA+IDAgPyAnKycgOiAnJ30ke2J0Yy5wcmljZUNoYW5nZTI0aC50b0ZpeGVkKDIpfSUuIGA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN1bW1hcnkgKz0gJy4gJztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChldGggJiYgdHlwZW9mIGV0aC5wcmljZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBzdW1tYXJ5ICs9IGBFdGhlcmV1bSBpcyB0cmFkaW5nIGF0ICQke2V0aC5wcmljZS50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQsIHttYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDJ9KX1gO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXRoLnByaWNlQ2hhbmdlMjRoID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgc3VtbWFyeSArPSBgIHdpdGggYSAyNGggY2hhbmdlIG9mICR7ZXRoLnByaWNlQ2hhbmdlMjRoID4gMCA/ICcrJyA6ICcnfSR7ZXRoLnByaWNlQ2hhbmdlMjRoLnRvRml4ZWQoMil9JS4gYDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3VtbWFyeSArPSAnLiAnO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQWRkIGFuYWx5c2lzIG9mIG90aGVyIG5vdGFibGUgY3J5cHRvY3VycmVuY2llc1xyXG4gICAgICBjb25zdCBvdGhlckNyeXB0b3MgPSBkYXRhLmNyeXB0b0RhdGEuZmlsdGVyKChjOiBhbnkpID0+IFxyXG4gICAgICAgIGM/LnN5bWJvbCAhPT0gJ0JUQycgJiYgYz8uc3ltYm9sICE9PSAnRVRIJyAmJiB0eXBlb2YgYz8ucHJpY2UgPT09ICdudW1iZXInICYmIHR5cGVvZiBjPy5wcmljZUNoYW5nZTI0aCA9PT0gJ251bWJlcidcclxuICAgICAgKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChvdGhlckNyeXB0b3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIFNvcnQgYnkgcHJpY2UgY2hhbmdlIHRvIGZpbmQgYmlnZ2VzdCBnYWluZXJzL2xvc2Vyc1xyXG4gICAgICAgIGNvbnN0IHNvcnRlZEJ5Q2hhbmdlID0gWy4uLm90aGVyQ3J5cHRvc10uc29ydCgoYSwgYikgPT4gYi5wcmljZUNoYW5nZTI0aCAtIGEucHJpY2VDaGFuZ2UyNGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEdyYWIgdG9wIGdhaW5lciBhbmQgbG9zZXJcclxuICAgICAgICBjb25zdCB0b3BHYWluZXIgPSBzb3J0ZWRCeUNoYW5nZVswXTtcclxuICAgICAgICBjb25zdCB0b3BMb3NlciA9IHNvcnRlZEJ5Q2hhbmdlW3NvcnRlZEJ5Q2hhbmdlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN1bW1hcnkgKz0gYFxcblxcbkFtb25nIGFsdGNvaW5zLCBgO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0b3BHYWluZXIgJiYgdG9wR2FpbmVyLnByaWNlQ2hhbmdlMjRoID4gMCkge1xyXG4gICAgICAgICAgc3VtbWFyeSArPSBgJHt0b3BHYWluZXIubmFtZX0gKCR7dG9wR2FpbmVyLnN5bWJvbH0pIGlzIHRoZSB0b3AgcGVyZm9ybWVyIHdpdGggYSAke3RvcEdhaW5lci5wcmljZUNoYW5nZTI0aCA+IDAgPyAnKycgOiAnJ30ke3RvcEdhaW5lci5wcmljZUNoYW5nZTI0aC50b0ZpeGVkKDIpfSUgcHJpY2UgY2hhbmdlLCBjdXJyZW50bHkgYXQgJCR7dG9wR2FpbmVyLnByaWNlLnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwge21heGltdW1GcmFjdGlvbkRpZ2l0czogMn0pfS4gYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRvcExvc2VyICYmIHRvcExvc2VyLnByaWNlQ2hhbmdlMjRoIDwgMCkge1xyXG4gICAgICAgICAgc3VtbWFyeSArPSBgJHt0b3BMb3Nlci5uYW1lfSAoJHt0b3BMb3Nlci5zeW1ib2x9KSBzaG93cyB0aGUgbGFyZ2VzdCBkZWNsaW5lIGF0ICR7dG9wTG9zZXIucHJpY2VDaGFuZ2UyNGgudG9GaXhlZCgyKX0lLCB0cmFkaW5nIGF0ICQke3RvcExvc2VyLnByaWNlLnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwge21heGltdW1GcmFjdGlvbkRpZ2l0czogMn0pfS4gYDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQWRkIGNvbmNsdXNpb24gYW5kIHJlY29tbWVuZGF0aW9uc1xyXG4gICAgc3VtbWFyeSArPSBgXFxuXFxuSW4gc3VtbWFyeSwgJHtnZW5lcmF0ZUR5bmFtaWNDb25jbHVzaW9uKHF1ZXJ5LCBkYXRhKX1gO1xyXG4gICAgXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdlbmVyYXRlRmFsbGJhY2tTdW1tYXJ5OicsIGVycm9yKTtcclxuICAgIHN1bW1hcnkgPSAnQW5hbHlzaXMgY29tcGxldGVkIHdpdGggYXZhaWxhYmxlIGRhdGEuIFNvbWUgc291cmNlcyBtYXkgYmUgdW5hdmFpbGFibGUuJztcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHN1bW1hcnkgfHwgJ0FuYWx5c2lzIGNvbXBsZXRlZCB3aXRoIGF2YWlsYWJsZSBkYXRhLiBTb21lIHNvdXJjZXMgbWF5IGJlIHVuYXZhaWxhYmxlLic7XHJcbn1cclxuXHJcbi8vIEdlbmVyYXRlIGEgZHluYW1pYyBjb25jbHVzaW9uIGJhc2VkIG9uIHRoZSBxdWVyeSBhbmQgZGF0YVxyXG5mdW5jdGlvbiBnZW5lcmF0ZUR5bmFtaWNDb25jbHVzaW9uKHF1ZXJ5OiBzdHJpbmcsIGRhdGE6IGFueSk6IHN0cmluZyB7XHJcbiAgY29uc3QgcXVlcnlMb3dlciA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XHJcbiAgbGV0IGNvbmNsdXNpb24gPSAnJztcclxuICBcclxuICAvLyBDaGVjayBpZiBtYXJrZXQgaXMgbW9zdGx5IHVwIG9yIGRvd25cclxuICBsZXQgcG9zaXRpdmVDaGFuZ2VzID0gMDtcclxuICBsZXQgbmVnYXRpdmVDaGFuZ2VzID0gMDtcclxuICBcclxuICAvLyBDb3VudCBwcmljZSBjaGFuZ2VzIGRpcmVjdGlvblxyXG4gIGlmIChkYXRhLmNyeXB0b0RhdGEgJiYgQXJyYXkuaXNBcnJheShkYXRhLmNyeXB0b0RhdGEpKSB7XHJcbiAgICBkYXRhLmNyeXB0b0RhdGEuZm9yRWFjaCgoY3J5cHRvOiBhbnkpID0+IHtcclxuICAgICAgaWYgKGNyeXB0bz8ucHJpY2VDaGFuZ2UyNGggPiAwKSBwb3NpdGl2ZUNoYW5nZXMrKztcclxuICAgICAgZWxzZSBpZiAoY3J5cHRvPy5wcmljZUNoYW5nZTI0aCA8IDApIG5lZ2F0aXZlQ2hhbmdlcysrO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIENvdW50IFRWTCBjaGFuZ2VzIGRpcmVjdGlvblxyXG4gIGlmIChkYXRhLmRlZmlQcm9qZWN0cyAmJiBBcnJheS5pc0FycmF5KGRhdGEuZGVmaVByb2plY3RzKSkge1xyXG4gICAgZGF0YS5kZWZpUHJvamVjdHMuZm9yRWFjaCgocHJvamVjdDogYW55KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNoYW5nZSA9IHByb2plY3Q/LnR2bENoYW5nZTI0aCB8fCBwcm9qZWN0Py50dmxDaGFuZ2U3ZDtcclxuICAgICAgaWYgKGNoYW5nZSA+IDApIHBvc2l0aXZlQ2hhbmdlcysrO1xyXG4gICAgICBlbHNlIGlmIChjaGFuZ2UgPCAwKSBuZWdhdGl2ZUNoYW5nZXMrKztcclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBtYXJrZXRTZW50aW1lbnQgPSBwb3NpdGl2ZUNoYW5nZXMgPiBuZWdhdGl2ZUNoYW5nZXMgPyAncG9zaXRpdmUnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmVDaGFuZ2VzID4gcG9zaXRpdmVDaGFuZ2VzID8gJ25lZ2F0aXZlJyA6ICdtaXhlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgLy8gR2VuZXJhdGUgY29uY2x1c2lvbiBiYXNlZCBvbiBxdWVyeSB0eXBlXHJcbiAgaWYgKHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2ludmVzdCcpIHx8IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2J1eScpKSB7XHJcbiAgICBzd2l0Y2ggKG1hcmtldFNlbnRpbWVudCkge1xyXG4gICAgICBjYXNlICdwb3NpdGl2ZSc6XHJcbiAgICAgICAgY29uY2x1c2lvbiA9ICd0aGUgbWFya2V0IGlzIHNob3dpbmcgbW9zdGx5IHBvc2l0aXZlIG1vbWVudHVtLiBDb25zaWRlciByZXNlYXJjaGluZyBwcm9qZWN0cyB3aXRoIHN0cm9uZyBmdW5kYW1lbnRhbHMgYW5kIGNvbnNpc3RlbnQgZ3Jvd3RoIGJlZm9yZSBtYWtpbmcgaW52ZXN0bWVudCBkZWNpc2lvbnMuIEFsd2F5cyBkaXZlcnNpZnkgeW91ciBwb3J0Zm9saW8gYW5kIGludmVzdCBvbmx5IHdoYXQgeW91IGNhbiBhZmZvcmQgdG8gbG9zZS4nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICduZWdhdGl2ZSc6XHJcbiAgICAgICAgY29uY2x1c2lvbiA9ICd0aGUgbWFya2V0IGlzIHNob3dpbmcgc29tZSBiZWFyaXNoIHNpZ25hbHMuIENvbnNpZGVyIHdhaXRpbmcgZm9yIHN0YWJpbGl0eSBvciBsb29rIGZvciBwcm9qZWN0cyB0aGF0IGhhdmUgc2hvd24gcmVzaWxpZW5jZSBkdXJpbmcgZG93bnR1cm5zLiBSaXNrIG1hbmFnZW1lbnQgc2hvdWxkIGJlIHByaW9yaXRpemVkIGluIGN1cnJlbnQgY29uZGl0aW9ucy4nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNvbmNsdXNpb24gPSAndGhlIG1hcmtldCBzaG93cyBtaXhlZCBzaWduYWxzLiBGb2N1cyBvbiBwcm9qZWN0cyB3aXRoIHN0cm9uZyBmdW5kYW1lbnRhbHMgYW5kIGNvbnNpZGVyIGRvbGxhci1jb3N0IGF2ZXJhZ2luZyByYXRoZXIgdGhhbiBsdW1wLXN1bSBpbnZlc3RtZW50cyBnaXZlbiB0aGUgY3VycmVudCB2b2xhdGlsaXR5Lic7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChxdWVyeUxvd2VyLmluY2x1ZGVzKCd0cmVuZCcpIHx8IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ21vdmVtZW50JykpIHtcclxuICAgIHN3aXRjaCAobWFya2V0U2VudGltZW50KSB7XHJcbiAgICAgIGNhc2UgJ3Bvc2l0aXZlJzpcclxuICAgICAgICBjb25jbHVzaW9uID0gJ3RoZSBjdXJyZW50IHRyZW5kIGFwcGVhcnMgYnVsbGlzaCB3aXRoIG1vc3QgYXNzZXRzIHNob3dpbmcgcG9zaXRpdmUgcHJpY2UgYWN0aW9uLiBLZWVwIGFuIGV5ZSBvbiB0cmFkaW5nIHZvbHVtZXMgYW5kIHBvdGVudGlhbCByZXNpc3RhbmNlIGxldmVscyB0aGF0IG1pZ2h0IGluZGljYXRlIHRyZW5kIHJldmVyc2Fscy4nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICduZWdhdGl2ZSc6XHJcbiAgICAgICAgY29uY2x1c2lvbiA9ICd0aGUgdHJlbmQgYXBwZWFycyBiZWFyaXNoIGluIHRoZSBzaG9ydCB0ZXJtIHdpdGggc2V2ZXJhbCBhc3NldHMgc2hvd2luZyBwcmljZSBkZWNsaW5lcy4gV2F0Y2ggZm9yIHBvdGVudGlhbCBzdXBwb3J0IGxldmVscyB3aGVyZSByZXZlcnNhbHMgbWlnaHQgb2NjdXIuJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjb25jbHVzaW9uID0gJ3dlXFwncmUgc2VlaW5nIGNvbnNvbGlkYXRpb24gYWNyb3NzIG1hbnkgYXNzZXRzIHdpdGggbWl4ZWQgc2lnbmFscy4gVGhpcyBvZnRlbiBwcmVjZWRlcyBzaWduaWZpY2FudCBtYXJrZXQgbW92ZW1lbnRzLCBzbyBtb25pdG9yIGtleSB0ZWNobmljYWwgaW5kaWNhdG9ycyBmb3IgYnJlYWtvdXQgc2lnbmFscy4nO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBzd2l0Y2ggKG1hcmtldFNlbnRpbWVudCkge1xyXG4gICAgICBjYXNlICdwb3NpdGl2ZSc6XHJcbiAgICAgICAgY29uY2x1c2lvbiA9ICd0aGUgb3ZlcmFsbCBjcnlwdG8gbWFya2V0IHNob3dzIHN0cmVuZ3RoIGF0IHRoZSBtb21lbnQuIEtlZXAgbW9uaXRvcmluZyBrZXkgcmVzaXN0YW5jZSBsZXZlbHMgYW5kIG5ld3MgZXZlbnRzIHRoYXQgbWlnaHQgaW1wYWN0IHRoaXMgcG9zaXRpdmUgdHJlbmQuJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnbmVnYXRpdmUnOlxyXG4gICAgICAgIGNvbmNsdXNpb24gPSAnY2F1dGlvbiBpcyBhZHZpc2VkIGFzIHNldmVyYWwgYXNzZXRzIGFyZSBzaG93aW5nIGRvd253YXJkIHByZXNzdXJlLiBDb25zaWRlciB3YXRjaGluZyBrZXkgc3VwcG9ydCBsZXZlbHMgYW5kIG1hcmtldCBjYXRhbHlzdHMgdGhhdCBjb3VsZCByZXZlcnNlIHRoaXMgdHJlbmQuJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjb25jbHVzaW9uID0gJ3RoZSBtYXJrZXQgbGFja3MgY2xlYXIgZGlyZWN0aW9uIGF0IHRoZSBtb21lbnQuIFRoaXMgbWlnaHQgcHJlc2VudCBvcHBvcnR1bml0aWVzIGZvciBib3RoIGVudHJpZXMgYW5kIGV4aXRzIGRlcGVuZGluZyBvbiB5b3VyIGludmVzdG1lbnQgc3RyYXRlZ3kgYW5kIHJpc2sgdG9sZXJhbmNlLic7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBjb25jbHVzaW9uO1xyXG59XHJcblxyXG4vLyBSZWZpbmUgLyBmaWx0ZXIgdGhlIGRhdGEgdGFibGUgd2hlbiB0aGUgdXNlciBleHBsaWNpdGx5IGFza3MgdG8gY29tcGFyZSBhIHNtYWxsIHNldCBvZiB0b2tlbnMvcHJvamVjdHMuXHJcbmZ1bmN0aW9uIHJlZmluZUNvbXBhcmlzb25UYWJsZShxdWVyeTogc3RyaW5nLCByYXdEYXRhOiBhbnksIGV4aXN0aW5nOiBEYXRhVGFibGVSb3dbXSk6IERhdGFUYWJsZVJvd1tdIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcSA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoIS9jb21wYXJlfHZzfHZlcnN1cy8udGVzdChxKSkgcmV0dXJuIGV4aXN0aW5nOyAvLyBvbmx5IGFwcGx5IG9uIGNvbXBhcmlzb24gaW50ZW50XHJcblxyXG4gICAgLy8gRXh0cmFjdCBleHBsaWNpdCB0b2tlbnMgKHN5bWJvbHMpIGFuZCBwcm9qZWN0IG5hbWUgd29yZHNcclxuICAgIGNvbnN0IHRva2VucyA9IGV4dHJhY3RUb2tlbnMocXVlcnkpOyAvLyByZXR1cm5zIHVwcGVyY2FzZSBzeW1ib2xzXHJcbiAgICBjb25zdCBuYW1lVGFyZ2V0cyA9IHRva2Vucy5tYXAodCA9PiB0LnRvTG93ZXJDYXNlKCkpO1xyXG5cclxuICAgIC8vIEFsc28gY2FwdHVyZSBjb21tb24gZnVsbCBuYW1lcyBmb3IgRVRIICYgQlRDIGV0Y1xyXG4gICAgY29uc3QgZXh0cmFOYW1lTWFwOiBSZWNvcmQ8c3RyaW5nLHN0cmluZ1tdPiA9IHtcclxuICAgICAgJ0VUSCc6IFsnZXRoZXJldW0nXSxcclxuICAgICAgJ0JUQyc6IFsnYml0Y29pbiddLFxyXG4gICAgICAnU09MJzogWydzb2xhbmEnXSxcclxuICAgICAgJ0JOQic6IFsnYm5iJywgJ2JpbmFuY2UnXSxcclxuICAgICAgJ0FEQSc6IFsnY2FyZGFubyddLFxyXG4gICAgfTtcclxuICAgIHRva2Vucy5mb3JFYWNoKHN5bSA9PiB7XHJcbiAgICAgIChleHRyYU5hbWVNYXBbc3ltXSB8fCBbXSkuZm9yRWFjaChuID0+IG5hbWVUYXJnZXRzLnB1c2gobikpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSWYgdXNlciBvbmx5IG1lbnRpb25zIHR3byB0byBmaXZlIGl0ZW1zLCB3ZSByZXN0cmljdCB0byB0aGVtIHN0cmljdGx5LlxyXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPj0gMiAmJiB0b2tlbnMubGVuZ3RoIDw9IDYpIHtcclxuICAgICAgY29uc3QgZmlsdGVyZWQgPSBleGlzdGluZy5maWx0ZXIociA9PiB7XHJcbiAgICAgICAgY29uc3QgcHJvaiA9IHIucHJvamVjdD8udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4gbmFtZVRhcmdldHMuc29tZSh0ID0+IHByb2ouaW5jbHVkZXModCkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIElmIG1vZGVsIHJldHVybmVkIHVucmVsYXRlZCByb3dzIGFuZCB3ZSBsb3N0IGV2ZXJ5dGhpbmcsIHJlYnVpbGQgZnJvbSByYXcgY3J5cHRvIGRhdGEgZm9yIHRob3NlIHRva2Vucy5cclxuICAgICAgaWYgKGZpbHRlcmVkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnN0IHJlYnVpbHQ6IERhdGFUYWJsZVJvd1tdID0gW107XHJcbiAgICAgICAgKHJhd0RhdGEuY3J5cHRvRGF0YSB8fCBbXSkuZm9yRWFjaCgoYzogYW55KSA9PiB7XHJcbiAgICAgICAgICBpZiAodG9rZW5zLmluY2x1ZGVzKGMuc3ltYm9sKSkge1xyXG4gICAgICAgICAgICByZWJ1aWx0LnB1c2goe1xyXG4gICAgICAgICAgICAgIHByb2plY3Q6IGMubmFtZSxcclxuICAgICAgICAgICAgICB0dmw6ICdOL0EnLFxyXG4gICAgICAgICAgICAgIHR2bENoYW5nZTogJ04vQScsXHJcbiAgICAgICAgICAgICAgcHJpY2U6IHR5cGVvZiBjLnByaWNlID09PSAnbnVtYmVyJyA/IGAkJHtjLnByaWNlLnRvRml4ZWQoMil9YCA6ICdOL0EnLFxyXG4gICAgICAgICAgICAgIHByaWNlQ2hhbmdlOiB0eXBlb2YgYy5wcmljZUNoYW5nZTI0aCA9PT0gJ251bWJlcicgPyBgJHtjLnByaWNlQ2hhbmdlMjRoPjA/JysnOicnfSR7Yy5wcmljZUNoYW5nZTI0aC50b0ZpeGVkKDIpfSVgIDogJ04vQScsXHJcbiAgICAgICAgICAgICAgc2VudGltZW50OiBjLnByaWNlQ2hhbmdlMjRoID4gMiA/ICdQb3NpdGl2ZScgOiBjLnByaWNlQ2hhbmdlMjRoIDwgLTIgPyAnTmVnYXRpdmUnIDogJ05ldXRyYWwnLFxyXG4gICAgICAgICAgICAgIG5ld3NDb3VudDogYy5zeW1ib2wgPT09ICdFVEgnID8gMjAgOiBjLnN5bWJvbCA9PT0gJ0JUQycgPyAyNSA6IDEwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZWJ1aWx0LnNsaWNlKDAsIHRva2Vucy5sZW5ndGgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmVzZXJ2ZSBvcmRlciBvZiBhcHBlYXJhbmNlIGluIHF1ZXJ5IGJ5IHNvcnRpbmcgZmlsdGVyZWQgcm93cyBhY2NvcmRpbmdseVxyXG4gICAgICBjb25zdCBvcmRlciA9IG5hbWVUYXJnZXRzO1xyXG4gICAgICBmaWx0ZXJlZC5zb3J0KChhLGIpID0+IG9yZGVyLmZpbmRJbmRleCh0ID0+IGEucHJvamVjdC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHQpKSAtIG9yZGVyLmZpbmRJbmRleCh0ID0+IGIucHJvamVjdC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHQpKSk7XHJcbiAgICAgIHJldHVybiBmaWx0ZXJlZC5zbGljZSgwLCB0b2tlbnMubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBleGlzdGluZztcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ3JlZmluZUNvbXBhcmlzb25UYWJsZSBmYWlsZWQsIHJldHVybmluZyBvcmlnaW5hbCB0YWJsZScsIGUpO1xyXG4gICAgcmV0dXJuIGV4aXN0aW5nO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlSW5zaWdodHMocXVlcnk6IHN0cmluZywgZGF0YTogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcHJvbXB0ID0gYFxyXG5CYXNlZCBvbiB0aGUgZm9sbG93aW5nIGNyeXB0byBkYXRhLCBwcm92aWRlIGluc2lnaHRzIGZvciB0aGUgcXVlcnk6IFwiJHtxdWVyeX1cIlxyXG5cclxuRGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKX1cclxuXHJcblByb3ZpZGUgYSBjb25jaXNlLCBwcm9mZXNzaW9uYWwgYW5hbHlzaXMgZm9jdXNpbmcgb246XHJcbi0gS2V5IHRyZW5kcyBhbmQgcGF0dGVybnNcclxuLSBOb3RhYmxlIGNoYW5nZXMgaW4gbWV0cmljc1xyXG4tIFBvdGVudGlhbCBpbXBsaWNhdGlvbnMgZm9yIGludmVzdG9yc1xyXG4tIFJpc2sgZmFjdG9ycyB0byBjb25zaWRlclxyXG5gO1xyXG5cclxuICAgIGxldCByZXRyeUNvdW50ID0gMDtcclxuICAgIGNvbnN0IG1heFJldHJpZXMgPSAyO1xyXG4gICAgbGV0IHJldHJ5RGVsYXkgPSAxMDAwOyAvLyBTdGFydCB3aXRoIDEgc2Vjb25kIGRlbGF5XHJcbiAgICBcclxuICAgIHdoaWxlIChyZXRyeUNvdW50IDw9IG1heFJldHJpZXMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjb21wbGV0aW9uID0gYXdhaXQgZ3JvcS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XHJcbiAgICAgICAgICBtZXNzYWdlczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgcm9sZTogJ3N5c3RlbScsXHJcbiAgICAgICAgICAgICAgY29udGVudDogJ1lvdSBhcmUgYSBjcnlwdG8gbWFya2V0IGFuYWx5c3QuIFByb3ZpZGUgY2xlYXIsIGFjdGlvbmFibGUgaW5zaWdodHMuJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcclxuICAgICAgICAgICAgICBjb250ZW50OiBwcm9tcHQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgbW9kZWw6IGdldEN1cnJlbnRNb2RlbChyZXRyeUNvdW50KSxcclxuICAgICAgICAgIHRlbXBlcmF0dXJlOiAwLjMsXHJcbiAgICAgICAgICBtYXhfdG9rZW5zOiAxMDAwLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY29tcGxldGlvbi5jaG9pY2VzWzBdPy5tZXNzYWdlPy5jb250ZW50IHx8ICdVbmFibGUgdG8gZ2VuZXJhdGUgaW5zaWdodHMgYXQgdGhpcyB0aW1lLic7XHJcbiAgICAgIH0gY2F0Y2ggKHJldHJ5RXJyb3IpIHtcclxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXRyeUVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyByZXRyeUVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XHJcbiAgICAgICAgY29uc3QgaXNDYXBhY2l0eUVycm9yID0gZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdvdmVyIGNhcGFjaXR5Jyk7XHJcbiAgICAgICAgY29uc3QgaXNSYXRlTGltaXRFcnJvciA9IGVycm9yTWVzc2FnZS5pbmNsdWRlcygncmF0ZV9saW1pdF9leGNlZWRlZCcpIHx8IGVycm9yTWVzc2FnZS5pbmNsdWRlcygnUmF0ZSBsaW1pdCByZWFjaGVkJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgR3JvcSBBUEkgZXJyb3IgKCR7aXNSYXRlTGltaXRFcnJvciA/ICdyYXRlIGxpbWl0JyA6IChpc0NhcGFjaXR5RXJyb3IgPyAnY2FwYWNpdHkgaXNzdWUnIDogJ2dlbmVyYWwgZXJyb3InKX0pIC0gYXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfS8ke21heFJldHJpZXMgKyAxfTpgLCByZXRyeUVycm9yKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocmV0cnlDb3VudCA+PSBtYXhSZXRyaWVzKSB7XHJcbiAgICAgICAgICB0aHJvdyByZXRyeUVycm9yOyAvLyBSZS10aHJvdyBpZiB3ZSd2ZSBleGhhdXN0ZWQgcmV0cmllc1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDYWxjdWxhdGUgYmFja29mZiBkZWxheSB3aXRoIGV4cG9uZW50aWFsIGluY3JlYXNlXHJcbiAgICAgICAgcmV0cnlEZWxheSAqPSAyO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBSZXRyeWluZyBpbiAke3JldHJ5RGVsYXl9bXMgd2l0aCBtb2RlbCBmYWxsYmFjay4uLmApO1xyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5KSk7XHJcbiAgICAgICAgcmV0cnlDb3VudCsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQgZHVlIHRvIHRoZSB0aHJvdyBpbiB0aGUgY2F0Y2ggYmxvY2sgYWJvdmVcclxuICAgIHJldHVybiAnVW5hYmxlIHRvIGdlbmVyYXRlIGluc2lnaHRzIGFmdGVyIG11bHRpcGxlIGF0dGVtcHRzLic7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgaW5zaWdodHM6JywgZXJyb3IpO1xyXG4gICAgXHJcbiAgICAvLyBJZiB0aGlzIGlzIGEgY2FwYWNpdHkvc2VydmVyIGVycm9yLCB1cGRhdGUgZW52IGZsYWcgdG8gc2tpcCBmdXR1cmUgQVBJIGNhbGxzXHJcbiAgICBpZiAoKGVycm9yIGFzIGFueSk/Lm1lc3NhZ2U/LmluY2x1ZGVzKCdvdmVyIGNhcGFjaXR5JykgfHwgKGVycm9yIGFzIGFueSk/LnN0YXR1cyA9PT0gNTAzKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gR3JvcSBBUEkgaXMgb3ZlciBjYXBhY2l0eSwgZW5hYmxpbmcgZmFsbGJhY2sgbW9kZScpO1xyXG4gICAgICBwcm9jZXNzLmVudi5TS0lQX0dST1FfQVBJID0gJ3RydWUnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBHZW5lcmF0ZSBhIGZhbGxiYWNrIGluc2lnaHQgbWVzc2FnZSBiYXNlZCBvbiB0aGUgcXVlcnkgdHlwZVxyXG4gICAgY29uc3QgcXVlcnlMb3dlciA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICBcclxuICAgIGlmIChxdWVyeUxvd2VyLmluY2x1ZGVzKCdpbnZlc3QnKSB8fCBxdWVyeUxvd2VyLmluY2x1ZGVzKCdidXknKSkge1xyXG4gICAgICByZXR1cm4gJ0Jhc2VkIG9uIHRoZSBhdmFpbGFibGUgZGF0YSwgcmVtZW1iZXIgdGhhdCBjcnlwdG9jdXJyZW5jeSBpbnZlc3RtZW50cyBjYXJyeSBzaWduaWZpY2FudCByaXNrLiBBbHdheXMgY29uZHVjdCB0aG9yb3VnaCByZXNlYXJjaCwgZGl2ZXJzaWZ5IHlvdXIgcG9ydGZvbGlvLCBhbmQgaW52ZXN0IG9ubHkgd2hhdCB5b3UgY2FuIGFmZm9yZCB0byBsb3NlLic7XHJcbiAgICB9IGVsc2UgaWYgKHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ3RyZW5kJykgfHwgcXVlcnlMb3dlci5pbmNsdWRlcygnbWFya2V0JykpIHtcclxuICAgICAgcmV0dXJuICdNYXJrZXQgdHJlbmRzIHNob3cgdmFyeWluZyBwYXR0ZXJucyBhY3Jvc3MgZGlmZmVyZW50IGFzc2V0cy4gRm9jdXMgb24gZnVuZGFtZW50YWxzIGFuZCBsb25nLXRlcm0gcG90ZW50aWFsIHJhdGhlciB0aGFuIHNob3J0LXRlcm0gcHJpY2UgbW92ZW1lbnRzIHdoZW4gZXZhbHVhdGluZyBwcm9qZWN0cy4nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuICdUaGUgY3J5cHRvIG1hcmtldCBpcyBjb25zdGFudGx5IGV2b2x2aW5nLiBTdGF5IGluZm9ybWVkIGFib3V0IHByb2plY3QgZGV2ZWxvcG1lbnRzLCByZWd1bGF0b3J5IGNoYW5nZXMsIGFuZCBicm9hZGVyIG1hcmtldCBjb25kaXRpb25zIHRvIG1ha2UgYmV0dGVyIGRlY2lzaW9ucy4nO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiR3JvcSIsImZldGNoQWxsRGF0YSIsImV4dHJhY3RUb2tlbnMiLCJxdWVyeSIsInRva2VucyIsImZpbHRlciIsInRva2VuIiwidG9VcHBlckNhc2UiLCJpbmNsdWRlcyIsImV4dHJhY3RQcm9qZWN0cyIsInByb2plY3RzIiwicHJvamVjdCIsInRvTG93ZXJDYXNlIiwiZXh0cmFjdFRpbWVGcmFtZSIsIkdST1FfTU9ERUxTIiwiY3VycmVudE1vZGVsSW5kZXgiLCJnZXRHcm9xTW9kZWwiLCJuZXh0TW9kZWwiLCJsZW5ndGgiLCJncm9xIiwiTU9ERUxfRkFMTEJBQ0tTIiwiZ2V0Q3VycmVudE1vZGVsIiwicmV0cnlDb3VudCIsImluZGV4IiwiTWF0aCIsIm1pbiIsIm1vZGVsIiwiY29uc29sZSIsImxvZyIsImRldGVjdEludGVudHMiLCJxIiwiaXNDcnlwdG9SZWxhdGVkIiwidGVzdCIsInNob3dEZUZpIiwic2hvd1RhYmxlIiwiaXNDcnlwdG9RdWVyeSIsInNob3dFdGhlcnNjYW4iLCJnZW5lcmF0ZURhdGFUYWJsZUZyb21SYXdEYXRhIiwiZGF0YSIsImRlZmlQcm9qZWN0c0NvdW50IiwiZGVmaVByb2plY3RzIiwiY3J5cHRvRGF0YUNvdW50IiwiY3J5cHRvRGF0YSIsInRhYmxlUm93cyIsInF1ZXJ5Q29udGV4dCIsInRpbWVGcmFtZSIsInRvcE4iLCJ1c2VUcmVuZGluZyIsInByb2plY3RUb2tlbk1hcHBpbmciLCJBcnJheSIsImlzQXJyYXkiLCJzb3J0ZWRQcm9qZWN0cyIsInNvcnQiLCJhIiwiYiIsInR2bCIsInR2bENoYW5nZTdkIiwidHZsQ2hhbmdlMjRoIiwibGltaXQiLCJzbGljZSIsImZvckVhY2giLCJuYW1lIiwidG9rZW5TeW1ib2wiLCJzeW1ib2wiLCJmaW5kIiwiYyIsImZvdW5kQ3J5cHRvIiwiY3J5cHRvUHJpY2UiLCJwcmljZSIsImRlZmlQcm9qZWN0U2VudGltZW50cyIsInByaWNlQ2hhbmdlIiwicHJpY2VDaGFuZ2UyNGgiLCJ0dmxDaGFuZ2UiLCJzZW50aW1lbnQiLCJjb21iaW5lZENoYW5nZSIsIm5ld3NDb3VudCIsIm5ld3NFdmVudHMiLCJwcm9qZWN0TmV3cyIsIm5ld3MiLCJ0aXRsZSIsImZsb29yIiwicmFuZG9tIiwiYmFzZU5ld3NDb3VudCIsIm1heCIsImFicyIsInB1c2giLCJmb3JtYXRDdXJyZW5jeSIsImZvcm1hdFBlcmNlbnRhZ2UiLCJjcnlwdG8iLCJwbGFjZWhvbGRlclByb2plY3RzIiwicHJvamVjdFNlbnRpbWVudHMiLCJlcnJvciIsInZhbHVlIiwiaXNOYU4iLCJ0b0ZpeGVkIiwiYW5hbHl6ZUNyeXB0b0RhdGEiLCJEYXRlIiwidG9JU09TdHJpbmciLCJmb2N1c1Rva2VucyIsImZvY3VzUHJvamVjdHMiLCJ1c2VSYW5kb21PcmRlciIsImFsbERhdGEiLCJhbmFseXNpcyIsImdlbmVyYXRlQW5hbHlzaXNXaXRoRmFsbGJhY2siLCJ0cmFuc2Zvcm1lZERhdGEiLCJzb2NpYWxTZW50aW1lbnQiLCJldGhlcnNjYW5EYXRhIiwidW5kZWZpbmVkIiwicmVmaW5lZFRhYmxlIiwicmVmaW5lQ29tcGFyaXNvblRhYmxlIiwiZGF0YVRhYmxlIiwic3VtbWFyeSIsInNvdXJjZXMiLCJ0aW1lc3RhbXAiLCJCb29sZWFuIiwiT2JqZWN0Iiwia2V5cyIsImluc2lnaHRzIiwicmlza0ZhY3RvcnMiLCJtYXJrZXRUcmVuZHMiLCJFcnJvciIsIm1lc3NhZ2UiLCJtYXhSZXRyaWVzIiwiYXR0ZW1wdCIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJHUk9RX0FQSV9LRVkiLCJyZWR1Y2VkIiwicmVkdWNlRGF0YUZvck1vZGVsIiwicmVkdWNlZEpzb24iLCJKU09OIiwic3RyaW5naWZ5IiwiYXBwcm94SW5wdXRUb2tlbnMiLCJjZWlsIiwid2FybiIsImhhcmRUcmltIiwibWV0YSIsImFnZ3JlZ2F0ZXMiLCJ0b3BDcnlwdG8iLCJ0b3BEZUZpIiwibWFwIiwibiIsInQiLCJkIiwicHVibGlzaGVkQXQiLCJoYXJkVHJpbUpzb24iLCJzeXN0ZW1Qcm9tcHQiLCJ1c2VyUHJvbXB0IiwiY29tcGxldGlvbiIsImNoYXQiLCJjb21wbGV0aW9ucyIsImNyZWF0ZSIsIm1lc3NhZ2VzIiwicm9sZSIsImNvbnRlbnQiLCJ0ZW1wZXJhdHVyZSIsIm1heF90b2tlbnMiLCJ0b3BfcCIsInN0cmVhbSIsInJlc3BvbnNlIiwiY2hvaWNlcyIsImpzb25NYXRjaCIsIm1hdGNoIiwicGFyc2UiLCJwYXJzZUVycm9yIiwic3RhdHVzIiwibXNnIiwiUHJvbWlzZSIsInIiLCJzZXRUaW1lb3V0IiwiZGVsYXkiLCJwb3ciLCJyZXNvbHZlIiwicUxvd2VyIiwibWF4RGVGaSIsIm1heENyeXB0byIsIm1heE5ld3MiLCJtYXJrZXRDYXAiLCJ2b2x1bWUyNGgiLCJwIiwiY2hhaW5zIiwiZXRoZXJzY2FuR2FzIiwiZ2FzUHJpY2UiLCJMYXN0QmxvY2siLCJTYWZlR2FzUHJpY2UiLCJGYXN0IiwidHZsVG90YWwiLCJyZWR1Y2UiLCJzIiwiYXZnUHJpY2VDaGFuZ2UiLCJnZW5lcmF0ZWRUYWJsZSIsInF1ZXJ5RnJhZ21lbnQiLCJOdW1iZXIiLCJkZWZpQ291bnQiLCJjcnlwdG9Db3VudCIsImV0aGVyc2NhbiIsInN1Z2dlc3RlZFRhYmxlIiwiZSIsImdlbmVyYXRlRmFsbGJhY2tTdW1tYXJ5IiwicXVlcnlMb3dlciIsIm1lbnRpb25zQml0Y29pbiIsIm1lbnRpb25zRXRoZXJldW0iLCJtZW50aW9uc0RlRmkiLCJtZW50aW9uc1ByaWNlIiwibWVudGlvbnNUb3AiLCJ0b3BQcm9qZWN0cyIsImpvaW4iLCJ0b3RhbFRWTCIsInN1bSIsInByb2plY3RzV2l0aFRWTENoYW5nZSIsInNvcnRlZEJ5Q2hhbmdlIiwidG9wR2FpbmVyIiwidG9wTG9zZXIiLCJjaGFuZ2VWYWx1ZSIsIm5vdyIsImRhdGVTdHIiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJtb250aCIsImRheSIsInllYXIiLCJidGMiLCJldGgiLCJ0b0xvY2FsZVN0cmluZyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsIm90aGVyQ3J5cHRvcyIsImdlbmVyYXRlRHluYW1pY0NvbmNsdXNpb24iLCJjb25jbHVzaW9uIiwicG9zaXRpdmVDaGFuZ2VzIiwibmVnYXRpdmVDaGFuZ2VzIiwiY2hhbmdlIiwibWFya2V0U2VudGltZW50IiwicmF3RGF0YSIsImV4aXN0aW5nIiwibmFtZVRhcmdldHMiLCJleHRyYU5hbWVNYXAiLCJzeW0iLCJmaWx0ZXJlZCIsInByb2oiLCJzb21lIiwicmVidWlsdCIsIm9yZGVyIiwiZmluZEluZGV4IiwiZ2VuZXJhdGVJbnNpZ2h0cyIsInByb21wdCIsInJldHJ5RGVsYXkiLCJyZXRyeUVycm9yIiwiZXJyb3JNZXNzYWdlIiwiaXNDYXBhY2l0eUVycm9yIiwiaXNSYXRlTGltaXRFcnJvciIsIlNLSVBfR1JPUV9BUEkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/groq.ts\n");

/***/ })

};
;